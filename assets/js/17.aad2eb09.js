(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{375:function(t,v,_){"use strict";_.r(v);var o=_(42),l=Object(o.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"模块化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模块化"}},[t._v("#")]),t._v(" 模块化")]),t._v(" "),_("ul",[_("li",[t._v("ES6 客户端 Vue/React")]),t._v(" "),_("li",[t._v("引入")]),t._v(" "),_("li",[t._v("import xx from 'xxx'")]),t._v(" "),_("li",[t._v("as--\x3e 重命名")]),t._v(" "),_("li",[t._v("import {BrowserRouter as Router} from 'xxx'")]),t._v(" "),_("li",[t._v("import * as xxx from 'xxx' 将所有引入重命名为 xxx")]),t._v(" "),_("li"),t._v(" "),_("li",[t._v("暴露")]),t._v(" "),_("li",[t._v("export xxxx")]),t._v(" "),_("li",[t._v("export default xxxx")]),t._v(" "),_("li"),t._v(" "),_("li",[t._v("CommonJs 服务器 Nodejs/webpack")]),t._v(" "),_("li",[t._v("引入")]),t._v(" "),_("li",[t._v("require 引入")]),t._v(" "),_("li",[t._v("自定义模块的路径必须写./ ../开头")]),t._v(" "),_("li",[t._v("第三方模块, 直接写模块名")]),t._v(" "),_("li",[t._v("exports / module.exports 暴露")]),t._v(" "),_("li",[t._v("Nodejs 模块暴露的本质是 module.exports 的值")]),t._v(" "),_("li",[t._v("exports 是 module.exports 一个引用")]),t._v(" "),_("li"),t._v(" "),_("li",[t._v("进阶: ES6 模块化和 CommonJS 模块化的区别:")]),t._v(" "),_("li",[_("ol",[_("li",[t._v("commonJs 同步加载有缓存, ES6 是运行时(编译)加载的, 没有缓存")])])]),t._v(" "),_("li",[t._v("const { Button } = require('antd')")]),t._v(" "),_("li",[t._v("一旦引入, 就会将模块所有的内容全部加载到内存中, 缓存起来, 在执行后面代码")]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("import { Button } from 'antd'")])])]),t._v(" "),_("li",[t._v("创建一个只读的引用, 此时 antd 模块内容没有加载, 当后面使用到 Button 做操作的时候 才会去加载模块 antd 中的 button, 其他内容不加载, 就是因为 ES6 模块化是在用的时候再去引入, 所有在 webpack 中可以使用 tree shaking 的功能")])])])}),[],!1,null,null,null);v.default=l.exports}}]);