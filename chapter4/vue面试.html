<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue 面试 | note_web</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="shortcut icon" type="image/x-icon" href="./images/favicon.ico">
    <meta name="description" content="熊木木出版">
    
    <link rel="preload" href="/note_web/assets/css/0.styles.7cc68753.css" as="style"><link rel="preload" href="/note_web/assets/js/app.0a8a88e2.js" as="script"><link rel="preload" href="/note_web/assets/js/2.a8152735.js" as="script"><link rel="preload" href="/note_web/assets/js/20.367a78b7.js" as="script"><link rel="prefetch" href="/note_web/assets/js/10.0b7deae7.js"><link rel="prefetch" href="/note_web/assets/js/11.b28cb736.js"><link rel="prefetch" href="/note_web/assets/js/12.1e24d268.js"><link rel="prefetch" href="/note_web/assets/js/13.6a7dc0b8.js"><link rel="prefetch" href="/note_web/assets/js/14.5ebcae47.js"><link rel="prefetch" href="/note_web/assets/js/15.361aa7de.js"><link rel="prefetch" href="/note_web/assets/js/16.d753cdbb.js"><link rel="prefetch" href="/note_web/assets/js/17.aad2eb09.js"><link rel="prefetch" href="/note_web/assets/js/18.fb79d12c.js"><link rel="prefetch" href="/note_web/assets/js/19.b0404afa.js"><link rel="prefetch" href="/note_web/assets/js/21.2c0d84e8.js"><link rel="prefetch" href="/note_web/assets/js/22.58f449fc.js"><link rel="prefetch" href="/note_web/assets/js/23.fe2549f8.js"><link rel="prefetch" href="/note_web/assets/js/24.7fe34f57.js"><link rel="prefetch" href="/note_web/assets/js/25.c8dbb4c7.js"><link rel="prefetch" href="/note_web/assets/js/26.49c63d2e.js"><link rel="prefetch" href="/note_web/assets/js/27.65899db2.js"><link rel="prefetch" href="/note_web/assets/js/28.9363e098.js"><link rel="prefetch" href="/note_web/assets/js/29.aebf9855.js"><link rel="prefetch" href="/note_web/assets/js/3.03f151d4.js"><link rel="prefetch" href="/note_web/assets/js/30.5dab8d40.js"><link rel="prefetch" href="/note_web/assets/js/4.d5e2826f.js"><link rel="prefetch" href="/note_web/assets/js/5.9499be40.js"><link rel="prefetch" href="/note_web/assets/js/6.153d8ea2.js"><link rel="prefetch" href="/note_web/assets/js/7.2aac5bdb.js"><link rel="prefetch" href="/note_web/assets/js/8.84af4e42.js"><link rel="prefetch" href="/note_web/assets/js/9.747e23d2.js">
    <link rel="stylesheet" href="/note_web/assets/css/0.styles.7cc68753.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/note_web/" class="home-link router-link-active"><img src="/note_web/images/logo.png" alt="note_web" class="logo"> <span class="site-name can-hide">note_web</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/note_web/chapter1/html.html" class="nav-link">
  H5
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JS" class="dropdown-title"><span class="title">JS</span> <span class="arrow down"></span></button> <button type="button" aria-label="JS" class="mobile-dropdown-title"><span class="title">JS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note_web/chapter2/初级Js.html" class="nav-link">
  普通
</a></li><li class="dropdown-item"><!----> <a href="/note_web/chapter2/高级Js.html" class="nav-link">
  高级
</a></li></ul></div></div><div class="nav-item"><a href="/note_web/chapter3/移动端相关.html" class="nav-link">
  移动端
</a></div><div class="nav-item"><a href="/note_web/chapter4/基础使用.html" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/note_web/chapter6/常见问题.html" class="nav-link">
  常见问题
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/note_web/chapter1/html.html" class="nav-link">
  H5
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JS" class="dropdown-title"><span class="title">JS</span> <span class="arrow down"></span></button> <button type="button" aria-label="JS" class="mobile-dropdown-title"><span class="title">JS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note_web/chapter2/初级Js.html" class="nav-link">
  普通
</a></li><li class="dropdown-item"><!----> <a href="/note_web/chapter2/高级Js.html" class="nav-link">
  高级
</a></li></ul></div></div><div class="nav-item"><a href="/note_web/chapter3/移动端相关.html" class="nav-link">
  移动端
</a></div><div class="nav-item"><a href="/note_web/chapter4/基础使用.html" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/note_web/chapter6/常见问题.html" class="nav-link">
  常见问题
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/note_web/笔记指南.html" class="sidebar-link">笔记指南</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>一.H5</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note_web/chapter1/h5.html" class="sidebar-link">H5</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>二.JS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note_web/chapter2/初级Js.html" class="sidebar-link">初级 Js</a></li><li><a href="/note_web/chapter2/高级Js.html" class="sidebar-link">高级 Js</a></li><li><a href="/note_web/chapter2/自定义call-apply-bind方法.html" class="sidebar-link">自定义 call 和 apply 和 bind 方法</a></li><li><a href="/note_web/chapter2/ECMAScript.html" class="sidebar-link">ECMAScript</a></li><li><a href="/note_web/chapter2/node.html" class="sidebar-link">NodeJS</a></li><li><a href="/note_web/chapter2/git.html" class="sidebar-link">Git</a></li><li><a href="/note_web/chapter2/ajax.html" class="sidebar-link">AJAX</a></li><li><a href="/note_web/chapter2/git常用指令.html" class="sidebar-link">git 常用指令</a></li><li><a href="/note_web/chapter2/模块化.html" class="sidebar-link">模块化</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>三.移动端</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note_web/chapter3/移动端相关.html" class="sidebar-link">移动端相关</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>四.Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note_web/chapter4/基础使用.html" class="sidebar-link">基础使用</a></li><li><a href="/note_web/chapter4/项目中遇到的问题.html" class="sidebar-link">项目中遇到的问题</a></li><li><a href="/note_web/chapter4/vue面试.html" class="active sidebar-link">vue 面试</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/note_web/chapter4/源码.html" class="sidebar-link">源码解析</a></li><li><a href="/note_web/chapter4/vue扩展.html" class="sidebar-link">Vue 扩展</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>五.webpack</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note_web/chapter5/构建工具.html" class="sidebar-link">构建工具</a></li><li><a href="/note_web/chapter5/webpack总结.html" class="sidebar-link">总结 Webpack</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>六.常见问题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note_web/chapter6/常见问题.html" class="sidebar-link">常见问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>七.React</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note_web/chapter7/react面试.html" class="sidebar-link">react 面试</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>八.小程序</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note_web/chapter8/小程序面试.html" class="sidebar-link">小程序面试</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>九.面试总汇</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note_web/chapter9/面试总汇.html" class="sidebar-link">面试总汇</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue-面试"><a href="#vue-面试" class="header-anchor">#</a> vue 面试</h1> <h3 id="vue-的优点及缺点"><a href="#vue-的优点及缺点" class="header-anchor">#</a> Vue 的优点及缺点</h3> <ol><li>首先 Vue 最核心的两个特点，响应式和组件化。</li> <li><strong>响应式：</strong> 这也就是 vue.js 最大的优点，通过 MVVM 思想实现数据的双向绑定，通过虚拟 DOM 让我们可以用数据来操作 DOM，而不必去操作真实的 DOM，提升了性能。且让开发者有更多的时间去思考业务逻辑。</li> <li><strong>组件化：</strong> 把一个单页应用中的各个模块拆分到一个个组件当中，或者把一些公共的部分抽离出来做成一个可复用的组件。所以组件化带来的好处就是，提高了开发效率，方便重复使用，使项目的可维护性更强</li> <li>虚拟 DOM</li> <li>缺点:
<ol><li>基于对象配置文件的写法，也就是 options 写法，开发时不利于对一个属性的查找</li> <li>不利于 seo。</li> <li>初次加载时耗时多</li></ol></li></ol> <h3 id="谈一谈-vue-是什么"><a href="#谈一谈-vue-是什么" class="header-anchor">#</a> 谈一谈 Vue 是什么?</h3> <ol><li>Vue 是一个用于构建用户界面的渐进式框架，可以单独的使用 Vue 总的 api，也可以使用 Vue 中的底层服务。Vue 是基于 MVVM 模型的，在起初，前端是直接利用 JS 来操作 DOM 节点，利用浏览器原生的 api，但是由于后来原生的 api 不好用，还需要考虑到兼容性的问题，就引出了 jQuery，然后到后来的 MVC 模型，需要配合服务器，JS 可以在前端修改服务器渲染后的结果，但是，随着前端的页面越来越复杂，用户对于交互的要求也越来越高，要写出比较复杂的页面，光靠 MVC 和 jQuery 是不够的，所以后来就衍生了 MVVM 模型，也就是 Model-View-viewModel，Model 代表数据模型，可以在 Model 中定义数据和修改数据等业务逻辑，View 是视图层，负责将展示数据的，然后 ViewModel 就是用来监听模型数据的改变和控制视图的展示的。然后在 MVVM 中，View 和 Model 是没有直接联系的，都是通过 ViewModel 进行交互, Model 和 ViewModel 之间的交互是双向的，所以视图层的数据变化之后，会同步到 Model 中，而 Model 中的数据发生变化之后，也会同步到 View 视图层，然后 ViewModel 是通过双向数据绑定的方式，将 View 和 Model 层连接起来的。然后 Vue 中是有数据代理的，Vue 的实例对象代理了 data 对象，Vue 的实例对象是代理者，data 对象是被代理者。</li> <li>数据代理实际上就是先把 Vue 中的配置对象全部传入到 Vue 中，然后把配置对象中的 data 存在当前实例的$data 和_data 上，然后会通过 Object.keys 方法，把 data 中所有属性利用循环遍历的方法全部取出来，然后利用 Object.defineProperty 方法重新 get 方法和 set 方法，就实现了数据代理。然后会添加 watcher 监听数据，一旦数据发生变化之后，watcher 就会调用回调，通知虚拟 DOM 树，哪些变量发生变化了，然后就会经过 diff 算法，会生成一棵新的 DOM 树，然后把新的 DOM 树更新到页面上去，一旦数据发生变化之后，就会调用重写的 set 方法，就能改变 data 里面的数据，从而实现了双向数据绑定。
diff 算法就是一种优化，用来对比模块之间的差异化，因为真实 DOM 的开销是比较大的，所以就会很大情况下影响到性能，如果我们修改了页面中的某个数据，然后直接渲染到真实的 DOM 中，会引入整个 DOM 树的改变，引起重绘，所以就需要用到 diff 算法，diff 算法就对前后 DOM 树同一层节点进行比较的，只会判断哪些变化了，去更新变化的模块，其他模块全部不会改变。所以在项目中，需要循环的时候就需要加上 key 属性(唯一标识)，比如之前有 ABCD，后来改变成 BCD 了，如果没有 key 唯一标识，diff 算法就会把之前的全部删除，然后再添加 BCD，性能不好，所以给每个元素添加了一个 key 属性只会，diff 算法就会判断是否存在一样的 key，如果有就会保存下来，没有就会移除，就只会去移除 A，不会全部删除，达到高效的使用虚拟 DOM 的效果。</li> <li>然后在 vue 中是有模板解析的，所谓的模板解析就是把页面中的 html 模板里面使用到的表达式，解析成真正的数据，并渲染到界面上去，然后模板解析就是在创建 vue 实例对象的时候，会通过 compile 对象，保存 data 数据，然后通过配置对象中的 el 可以获取到页面对应的容器，如果没有容器的话，就会把 body 当成容器，然后就会在内存当中创建一个虚拟的 DOM 对象 Fragement,Fragement 对象也可以叫文档碎片对象，可以高效批量的操作 DOM 节点，然后是在内存当中完成对节点的操作方法。然后就会用 Fragement 来存储 div 容器中的所有节点，然后回进入 init 模板解析的方法，因为 Fragment 是一个伪数组，无法使用真数组的方法，所有就需要转换为真数组然后再调用数组的方法去遍历出来每一个节点
然后再判断这个节点是标签节点还是文本节点，如果当前的节点内部还有节点的话，就会进行递归遍历，直接无子节点了</li> <li>然后判断当前节点是不是文本节点，并且是否满足插值语法的正则，如果满足最终就会调用 bind 方法，然后内部会调用 updater 对象中的相关方法，对标签中的内容进行替换。
如果是标签节点，那么就会遍历这个标签中的所有属性，再判断该属性是不是一个指令，然后再判断这个指令是事件指令还是普通指令
如果是事件指令就是判断属性中是否含有 v-开头的指令，如果有利用 substriung 把 v-去除，然后再判断指令是否是事件指令，即有没有含有 on，如果是一个事件执行，那么就会把这个属性进行 split 按照 : 来切割，然后取出 : 后面的值，剩下的是事件的名字，然后通过 addEventListener 方法，为当前的节点绑定相对应事件
如果是普通指令，就会找到对应的 compileUtil 中的相关方法，最终执行 updater 对象中相关的方法，然后进行替换操作。</li> <li>无论是普通指令还是事件指令，最终都要通过 removeAttrbute 把标签上的相关属性删除，最终会渲染页面</li></ol> <h3 id="vue-的生命周期"><a href="#vue-的生命周期" class="header-anchor">#</a> Vue 的生命周期</h3> <p>Vue 是有生命周期的，一共有 11 个生命周期，一般开发中常用的生命周期就 8 个，分为 beforeCreate 组件开始创建前，Created 创建后，beforeMount 组件挂载前，Mounted 组件挂载后，beforeUpdate 数据更新前（还没更新），updated 更新后，beforeDestroy 销毁前，destroyed 销毁后，然后因为组件在挂载后才把 Vue 实例挂载上去，然后 DOM 渲染才完全渲染完毕。然后在加载组件的时候，只会执行一次，所以在项目中，一般在 mounted 生命周期中发送封装好的 ajax 请求，获取数据。在项目的开发过程中，可以利用 axios 封装请求拦截器和响应拦截器发送 ajax 请求，在好物社的项目中的登录功能中，在请求拦截器中判断用户的 token 有没有，然后设置请求如果正确就可以登录和访问之前用户浏览过的商品和用户的基本信息。</p> <h3 id="vue-中的组件通信方式"><a href="#vue-中的组件通信方式" class="header-anchor">#</a> Vue 中的组件通信方式</h3> <p>Vue 中的组件通信方式有
props 父子组件之间的通信、在好物社的分类组件中，有一个子组件，就是右边展示数据的组件，然后左边的导航是在分类组件的左侧，然后利用 props 在点击的左侧 nav 导航的时候，然后把当前的下标传入到子级组件内部，然后右边子组件根据父级组件传递过来的数据，进行相对应的数据展示。
事件总线的方式，在主文件中为 vue 的实例对象身上添加一个$bus，然后可以实现任意组件之间通信问题，需要数据的组件, 监听事件$on 然后加上自定义的事件名，在传递数据的组件, 分发该事件即可$emit。
然后还有自定义事件，可以实现任意组件进行通信
Vuex 进行任意组件进行通信，vuex 是多个组件的共享状态进行集中式的管理，vuex 分为 state 存储数据、getters 从 state 派生的数据，相当于计算属性、mutations 包含多个直接修改状态数据方法的对象，直接修改 state 里面的内容，actions 包含多个简介修改状态数据的方法，然后通过 commit 提交给 mutations 最后由 mutations 去修改 state 里面的状态数据。然后每个方法都对应一个 vuex 的辅助函数，分为 mapState、mapMutations、mapActions、mapGetter。可以在组件内部的计算属性 computed 里面去获取 vuex 中的数据, 也可以在组件挂载的时候，在生命周期 mounted 中使用通过 store.dispatch()分发 Actions.但是这个分开 actions 是异步的操作，返回的是 promise 状态，所以需要配合 ES7 推出的 async+await 配合 promise 使用，因为请求的数据是异步的，然后可能页面加载完毕之后，数据还没请求回来，所以需要用 async+await 但是一般都会定义一个函数再使用 async+await 然后在生命周期 mounted 中调用这个函数来分发 action，不会给生命周期添加 async 和 await，因为容易出现问题。
PubSub 可以实现任意组件的通信，但是 PubSub 不属于 vue 的</p> <h3 id="vue-中的路由"><a href="#vue-中的路由" class="header-anchor">#</a> Vue 中的路由</h3> <p>前端路由技术是一种映射的关系，地址和地址对应的组件之间的关系，根据地址不同，在页面中的指定位置可以渲染组件，其实就是一个 a 标签，点击的时候不会跳转，渲染新的内容就是改变相对应路径，然后在 vue 中实先单页面跳转，vue 中实现前端 spa 页面，就会用到 vue-router，然后把需要跳转的地方用 router-link 包裹，然后路由分为声明式路由和编程式路由, 声明式路由不需要 js 代码，直接写在标签上即可，编程式路由，需要 js 代码实现，然后需要配合 router-view 进行路由视图的展示和传递数据，然后路由中分为 hash 模式和 history 模式，hash 模式带#号，history 不带#号，刷新页面可能会出现 404, 因为当操作到分类页面的时候，此时地址栏已经变成了/category 然后当我们刷新的时候。服务器会发送一个/category 的请求, 但是我们打包后只有入口的 index.html 文件, 并没有 cateogy 路径，所以就会报错 404.解决方式可以在 webpack 中的 devServer 中配置 devServer: {historyApiFallback: true}如果请求开发服务器找不到资源的时候，就会重定向到 index.html 文件，当项目上线之后，仍然会出现 404，所以需要在访问静态资源服务器的请求全部以/开头，然后其他的正常请求全部已统一的名字开头，服务器就能通过访问资源的路径来区分是正常的请求还是非正常的请求。然后 hist 模式不存在这个问题，因为浏览器会把#后后面的路径不加载，所以就不存在 404。</p> <h3 id="vue-中为什么要有-key"><a href="#vue-中为什么要有-key" class="header-anchor">#</a> Vue 中为什么要有 key</h3> <p>因为不管是 vue 还是 react 都实现了虚拟 DOM，虚拟 DOM 都是有一套 diff 算法的，用来对比模块之间的差异化，因为真实 DOM 的开销是比较大的，所以就会很大情况下影响到性能，如果我们修改了页面中的某个数据，然后直接渲染到真实的 DOM 中，会引入整个 DOM 树的改变，引起重绘，所以就需要用到 diff 算法，diff 算法就对前后 DOM 树同一层节点进行比较的，只会判断哪些变化了，去更新变化的模块，其他模块全部不会改变。所以在项目中，需要循环的时候就需要加上 key 属性(唯一标识)，比如之前有 ABCD，后来改变成 BCD 了，如果没有 key 唯一标识，diff 算法就会把之前的全部删除，然后再添加 BCD，性能不好，所以给每个元素添加了一个 key 属性只会，diff 算法就会判断是否存在一样的 key，如果有就会保存下来，没有就会移除，就只会去移除 A，不会全部删除，就可以实现高效的使用虚拟 DOM</p> <h3 id="computed-和-watch-的区别"><a href="#computed-和-watch-的区别" class="header-anchor">#</a> computed 和 watch 的区别</h3> <p>计算属性 computed，是支持缓存，只有依赖数据发送变化的时候，才会重新计算、不支持异步操作，当 computed 内部有异步操作时无效，无法监听数据的变化，computed 属性值会默认走缓存，也就是基于 data 中声明过或者父组件传递过来的 props 中的数据，通过计算属性得到的值，然后计算属性是可以设置 get 和 set 方法的，当访问数据的时候会进入 get 方法，当数据变化的时候会进入 set 方法。
监听 watch，不支持缓存，数据变化，会直接触发相应的操作，是支持异步操作，监听的函数接受两个参数，一个是最新的值一个是之前的值，监听的数据也必须是 data 中定义的，或者父组件传递过来的，当数据发生变化的时候，触发其他的操作，监听的对象也可以写成字符串的形式，当数据变化的时候，需要执行异步或者开销较大的操作的时候，就使用 watch，如果不是一般用 cpmputed</p> <h3 id="vue-项目中遇到的问题"><a href="#vue-项目中遇到的问题" class="header-anchor">#</a> Vue 项目中遇到的问题</h3> <ol><li>创建 swiper 的时候,无效果,因为创建对象太早了,数据还没请求回来,需要在数据显示之后再创建,利用 watch 和 $nextTick()</li> <li>初始显示异常,就是当我们动态展示数据的时候报错,cannot reade property 'xx' of undefined,原因: 初始值是空对象,内部没有数据,而模块中直接显示 3 层表达式,可以在父级标签中使用 v-if 指令判断 2 层表达式是否存在,即可解决</li> <li>更新状态数据,对应的界面不变化, 一般方法给一个已有绑定对象中添加一个新属性,这个属性没有数据绑定,利用 vue.set(obj, 'xx' , value)才有数据</li></ol> <h3 id="vue-的理解"><a href="#vue-的理解" class="header-anchor">#</a> Vue 的理解</h3> <ul><li>Vue 是一套用于构建用户界面的渐进式框架, 可以单独的使用 vue 中的 api 也可以使用 vue 中的底层服务, 渐进式的话, 就可以比喻成 vscode, 本身实现的功能是有限的, 但是可以安装很多的插件, 来开发程序。vue 是一个 MVVM 的一个框架， 适合做电商类，后台管理系统的项目，项目中都用到 vue 全家桶，vue-router vuex axios，生命周期函数, 以及模板与数据绑定, 组件与虚拟 DOM 等技术</li></ul> <h3 id="vue-的优点是什么"><a href="#vue-的优点是什么" class="header-anchor">#</a> Vue 的优点是什么</h3> <ul><li>是一个轻量级的框架, 只关注视图层, 是一个构建数据的视图集合,响应式编程, 文件的体积很小。轻量级框架，双向数据绑定，组件化、视图、数据、结构的分离、虚拟 DOM、运行速度快，是单页面应用，使页面局部刷新，不用每次跳转页面都要请求所有数据和 dom，这样大大加快了访问速度，和提升用户体验。而且他的第三方 ui 库很多，节省开发时间</li></ul> <h3 id="mvvm-的理解"><a href="#mvvm-的理解" class="header-anchor">#</a> MVVM 的理解</h3> <ul><li>一开始是直接利用 JS 来操作 DOM 节点, 利用浏览器的原生 API</li> <li>然后由于原生的 API 不好用, 还要考虑兼容性的问题, 后来就使用 jQuery</li> <li>再后来 MVC 模型, 需要配合服务器端, js 可以在前端修改服务器渲染后的结果</li> <li>但是随着前端的页面越来越复杂, 用户对于交互的要求也越来越高, 要想写出复杂的页面, 仅仅使用 jQuery 和 MVC 模型是不够的, 然后就诞生了 MVVM 模型</li> <li>MVVM 是 Model-View-ViewModel 的缩写, Model 代表数据模型, 也可以在 Model 中定义数据修改和操作业务逻辑, View 代表 UI 组件, 他负责将数据模型转换成 UI 展示出来, ViewModel 监听模型数据的改变和控制视图行为, 处理用户交互, 就是同步 View 和 MOdel 的对象, 连接 Mode 和 View.</li> <li>在 MVVM 架构下, View 和 Model 之间并没有直接的联系, 是通过 ViewModel 进行交互的。Model 和 ViewModel 之间的交互是双向的, 因此 View 数据的变化会同步到 Model 中, 而 Model 数据的变化也会立即反应到 View 上, ViewModel 是通过双向数据绑定的方式, 把 View 层和 Model 层连接起来, 而 View 和 Model 之间的同步工作完全是自动的, 因为开发者只需要关注业务逻辑, 不需要手动操作 DOM, 不需要关注数据状态的同步问题, 复杂的数据状态维护完全由 MVVM 来统一管理</li></ul> <h3 id="vue-的生命周期-2"><a href="#vue-的生命周期-2" class="header-anchor">#</a> Vue 的生命周期</h3> <ul><li>Vue 是有生命周期的, 他的生命周期从开始创建-&gt; 初始化数据-&gt; 编译模板-&gt; 挂载-&gt; DOM 渲染-&gt; 更新渲染-&gt; 销毁等一系列的过程</li> <li>Vue 一共有 11 个生命周期, 但是常用的就 8 个</li> <li>beforeCreate(创建前) 还没初始化之前</li> <li>created(创建后) 初始化事件, 但是$el 属性还没显示</li> <li>beforeMount(挂载前) 挂载开始之前调用, render 函数首次被调用</li> <li>mounted(挂载后) el 被新创建的 vm.$el 代替, 并挂载到实例上去之后调用</li> <li>beforeUpdate(更新前) 数据更新之前调用</li> <li>updated(更新后) 数据更新之后调用</li> <li>beforeDestroy(销毁前) 在实例销毁之前调用, 实例仍然可用</li> <li>destroyed(销毁后) 在实例销毁之后调用, 实例不可用</li></ul> <h4 id="生命周期的作用"><a href="#生命周期的作用" class="header-anchor">#</a> 生命周期的作用</h4> <ul><li>生命周期中有多个事件钩子, 让我们在控制整个 Vue 实例的过程中更容易形成好的逻辑思维</li></ul> <h4 id="第一次页面加载会触发几个生命周期"><a href="#第一次页面加载会触发几个生命周期" class="header-anchor">#</a> 第一次页面加载会触发几个生命周期</h4> <ul><li>会触发个生命周期, 分别的 beforeCreate、created、beforeMount、mounted</li> <li>DOM 的渲染在 mounted 的时候就已经完成了</li></ul> <h3 id="vue-中实现双向数据绑定的原理"><a href="#vue-中实现双向数据绑定的原理" class="header-anchor">#</a> Vue 中实现双向数据绑定的原理</h3> <ul><li>vue 数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的.
1）数据劫持、vue 是通过 Object.defineProperty()来实现数据劫持，其中会有 getter()和 setter 方法；当读取属性值时，就会触发 getter()方法，在 view 中如果数据发生了变化，就会通过 Object.defineProperty( )对属性设置一个 setter 函数，当数据改变了就会来触发应的监听回调</li></ul> <h3 id="vue-中组件通信的方式"><a href="#vue-中组件通信的方式" class="header-anchor">#</a> Vue 中组件通信的方式</h3> <ol><li>props
<ul><li>父子之间通信</li></ul></li> <li>自定义事件
<ul><li>父子之间通信</li></ul></li> <li>PubSub(不属于 Vue)
<ul><li>任意组件通信</li></ul></li> <li>事件总线
<ul><li>就是在 Vue 的原型上添加一个属性, 该属性接收 Vue 的实例, 任意组件都要继承自 Vue, 所以都可以直接使用该属性, 调用相关的方法, 从而实现任意组件之间的通信</li> <li>需要数据的组件, 监听事件$on 然后加上自定义的事件名</li> <li>在传递数据的组件, 分发该事件即可$emit</li></ul></li> <li>插槽(普通插槽、命名插槽、作用域插槽)
<ul><li>普通插槽
<ul><li>子组件只能有一个插槽, 标签体内容在父组件中解析好后(数据在父组件), 传递给这个插槽</li></ul></li> <li>命名插槽
<ul><li>子组件有多个指定了 name 的插槽, 标签体内容在父组件中解析好之后, 分别传递给对于的插槽</li></ul></li> <li>作用域插槽
<ul><li>数据在子组件, 子组件有部分结构需要父组件传递, 当父组件需要读取子组件数据, 子组件需要先向父组件传递数据, 父组件根据数据渲染标签结构后传递给子组件的插槽</li></ul></li> <li>占位, 很多组件中(多个页面)用到了相同的结构和样式, 而且这些组件中有的地方用到不同的数据, 就可以使用插槽的方法, 用户父子和之父之间通信</li></ul></li> <li>Vuex
<ul><li>任意组件通信</li> <li>state 存储数据</li> <li>getters 从 state 派生的数据, 相对于 state 的计算属性</li> <li>mutations 包含多个直接修改状态数据的方法的对象 直接和 state 沟通</li> <li>actions 包含多个间接修改状态数据的方法的对象 然后 commit 提交给 mutations 最后由 mutations 和 state 沟通</li> <li>getters 包含了多个状态的计算属性的 get 方法的对象, 外部需要获取状态数据的值</li> <li>如果想要调用 actions 中的某个 action 那么需要调用 dispath()--&gt; 提交 action 修改状态数据</li> <li>在界面中想要获取到 action 里面的数据, 就可以调用辅助函数, ...mapActions(['xxx'])</li> <li>在界面中想要获取到 getter 里面的数据, 就可以调用辅助函数, ...mapGetters(['xxx'])</li> <li>在界面中想要获取到 mutations 里面的数据, 就可以调用辅助函数, ...mapMutations(['xxx'])</li> <li>在界面中想要获取到 state 里面的数据, 可以调用辅助函数, ...mapState(['xxx'])</li></ul></li></ol> <h3 id="路由"><a href="#路由" class="header-anchor">#</a> 路由</h3> <ol><li>前端路由技术一种映射的关系, 地址和地址对应的组件之间的关系, 根据地址的不同, 在页面中的指定位置可以渲染组件, 其实就是一个 a 标签, 点击的时候不会跳转, 渲染新的内容(改变路径)</li> <li>Vue 中如果实现单页面应用跳转, 就得用到 vue-router, 然后把需要跳转的地方用 router-link 包裹</li> <li>然后路由分为声明式路由和编程式路由</li> <li>声明式路由
<ol><li>不需要 js 代码直接写标签即可</li></ol></li> <li>编程式路由
<ol><li>需要 js 代码来实现</li></ol></li> <li>然后需要配合 router-view 路由视图向路由组件传递数据</li> <li>然后路由中有 hash 模式和 history 模式
<ol><li>hash 模式带#号, 只能改变#后面的 url 片段</li> <li>history 不带#号, 刷新会出现 404, 如果用户考虑 url 的规范, 就需要使用 history 模式</li></ol></li></ol> <h3 id="vue-中发送异步请求"><a href="#vue-中发送异步请求" class="header-anchor">#</a> Vue 中发送异步请求</h3> <ol><li>使用 axios 基于 ajax 和 promise 封装
<ol><li>可以设置请求拦截器和响应拦截器
<ol><li>可以在拦截器中判断有没有 token 然后设置请求的头的信息等</li></ol></li> <li>支持 promise API</li> <li>自动转换 JSON 数据</li> <li>提供并发请求的接口</li></ol></li> <li>axios.all()可以批量发送请求, 等所有的请求都有返回的之后, 再执行统一回调</li></ol> <h3 id="路由守卫"><a href="#路由守卫" class="header-anchor">#</a> 路由守卫</h3> <ol><li>全局守卫
<ol><li>是指路由实例上直接操作钩子函数, 特点是所有路由配置的组件都会触发</li> <li>beforeEach((to, from, next)=&gt;{})
<ol><li>to--&gt; 进入到哪个路由</li> <li>from--&gt; 从哪个路由离开</li></ol></li></ol></li> <li>局部守卫
<ol><li>指在组件内执行的钩子函数, 类似于组件内的生命周期</li></ol></li></ol> <h3 id="v-if-和-v-show-的区别"><a href="#v-if-和-v-show-的区别" class="header-anchor">#</a> v-if 和 v-show 的区别</h3> <ul><li>v-if 用来切换显示和不显示的, 用可能在 DOM 树中不存在, 因为可能会直接销毁</li> <li>v-show 用来切换显示和不显示, 但是在 DOM 树中一直存在, 因为操作的只是样式</li></ul> <h3 id="图片懒加载"><a href="#图片懒加载" class="header-anchor">#</a> 图片懒加载</h3> <ul><li>图片懒加载使用 vue-lazyload 插件, 在 img 标签中设置 v-lazy 即可</li></ul> <h3 id="date-为什么要-return"><a href="#date-为什么要-return" class="header-anchor">#</a> date 为什么要 return</h3> <ul><li>因为不适应 return 包裹的数据会在项目的全局可见, 会造成变量的污染, 使用 return 包裹后的数据中的变量, 只在当前组件中生效, 不会影响其他的组件</li></ul> <h3 id="为什么要有-key"><a href="#为什么要有-key" class="header-anchor">#</a> 为什么要有 key</h3> <ul><li>因为不管是 Vue 还是 React 都实现了虚拟 DOM, 虚拟 DOM 都是有一套 diff 算法的, 而 key 就是用来给每个节点做唯一的标识, Diff 算法就可以正确的识别此节点, 找到正确的位置插入新的节点, 主要作用就是高效的使用虚拟 DOM</li></ul> <h3 id="css-只在当前的组件有效"><a href="#css-只在当前的组件有效" class="header-anchor">#</a> css 只在当前的组件有效</h3> <ul><li>在 style 标签上添加 scoped 即可</li></ul> <h3 id="vue-常见的指令"><a href="#vue-常见的指令" class="header-anchor">#</a> Vue 常见的指令</h3> <ul><li>v-if、v-show、v-else、v-bind、v-for</li></ul> <h3 id="vue-中常见的修饰符"><a href="#vue-中常见的修饰符" class="header-anchor">#</a> Vue 中常见的修饰符</h3> <ul><li>.prevet 提交事件不会重载页面、 .stop 阻止事件冒泡、.self 当事件发生在该原生本身而不是子元素时触发</li></ul> <h3 id="computed-和-watch-区别"><a href="#computed-和-watch-区别" class="header-anchor">#</a> computed 和 watch 区别</h3> <ol><li>计算属性 computed
<ol><li>支持缓存, 只有依赖数据发生变化的时候, 才会重新计算</li> <li>不支持异步操作, 当 computed 内部有异步操作时无效, 无法监听数据的变化</li> <li>computed 属性值会默认走缓存, 也就是基于 data 中声明过或者父组件传递过来的 props 中的数据通过计算得到的值</li> <li>如果一个属性是由其他属性计算而来的, 这个属性依赖其他属性, 是一个多对一或者一对一的关系, 一般都用 computed</li> <li>然后计算属性中可以设置 get 和 set 方法, 当访问数据时会进入 get 方法, 数据变化的时候会进入 set</li></ol></li> <li>监听 watch
<ol><li>不支持缓存, 数据变化, 会直接触发相应的操作</li> <li>watch 支持异步操作</li> <li>监听的函数接收两个参数, 一个是最新的值, 第二个是输入之前的值</li> <li>当一个属性发生变化的时候, 需要执行的操作, 一般是一对多</li> <li>监听数据必须是 data 中声明过的, 或者父组件传递过来的 props 中的数据, 当数据变化的时候, 触发其他的操作</li> <li>监听的对象也可以写成字符串的形式</li></ol></li> <li>当数据变化的时候需要执行异步或者开销较大的操作的时候, 就使用 watch,如果不是一般用 computed</li></ol> <h3 id="vue-源码分析"><a href="#vue-源码分析" class="header-anchor">#</a> Vue 源码分析</h3> <h4 id="数据代理"><a href="#数据代理" class="header-anchor">#</a> 数据代理</h4> <ul><li>Vue<code>中是存在数据代理的,</code>Vue<code>的实例对象代理了data对象,</code>Vue`的实例对象是代理者, data 对象是被代理者</li> <li>数据代理实际上就是先是把<code>Vue</code>中的配置对象全部传入到<code>Vue</code>上,然后把配置对象中的 data, 存放在当前实例的$data 和_data 上, 然后通过 Object.keys 的方法, 把 data 中所有的属性利用循环遍历的方法把他们全部取出来, 然后在遍历的过程当中, 找到每一个属性, 然后把遍历出来的属性传入到实现数据代理的方法中, 找到当前<code>vm</code>的实例对象, 然后利用<code>Object.defineProperty</code>的方法把 data 对象中的每个属性添加到<code>Vue</code>的实例对象上, 然后重写整个属性里面的 get 方法和 set 方法, 从而实现数据代理</li></ul> <h4 id="数据的劫持和监视中的dep对象和watcher的关系"><a href="#数据的劫持和监视中的dep对象和watcher的关系" class="header-anchor">#</a> 数据的劫持和监视中的<code>dep</code>对象和<code>watcher</code>的关系</h4> <ul><li>data 里面叫属性, 模板容器中叫表达式</li> <li>data 中有几个属性, 就会创建多少个<code>dep</code>对象</li> <li>模板容器中有几个表达式, 就会创建多少个<code>watcher</code>对象</li> <li>先会进入 observer(), 然后会根据 data 中有多少属性, 就会创建多少个<code>dep</code>对象(id,subs 数组),然后会遍历<code>vm</code>实例对象中<code>data</code>内的全部属性, 然后全部添加到劫持对象的<code>data</code>对象中, 然后重写 get 方法和 set 方法, 然后数据的劫持操作就完成了.</li> <li>数据的劫持操作全部完成之后, <code>dep</code>对象也全部创建完毕了, 之后就会进入到<code>mvvm</code>的创建模板解析, 然后会进入到 compile 的模板解析的方法, 然后最终都会调用 bind 方法, 然后在 bind 方法的内部会创建新的 watcher 对象(监视对象), 然后会根据模板容器中有多少个表达式就会创建多少个相对应的 watcher 对象</li> <li>当进入到 watcher 构造函数内部的时候, 首先会调用一个 get 方法, 然后会在 Watcher 对象的 getter 属性上调用一个<code>parseGetter</code>的函数, 然后该函数会返回一个函数, 然后可以在返回的函数中得到表达式返回的值, 然后因为内部会使用到<code>vm</code>实例中的 data 对象中的数据, 所有一定会进入到<code>mvvm.js</code>文件中的 get 方法内部, 然后因为<code>observer.js</code>文件中重写了 data 对象, 所有也会进入到<code>observer.js</code>文件中的 get 方法内部, 在<code>observer.js</code>文件中的 get 方法内部, 会调用一个 depend()方法, 这个方法的内部调用了<code>watcher.js</code>文件的<code>addDep()</code>方法, 然后把<code>dep</code>对象传入进去, 此时就开始建立联系了, 然后会进入到<code>watcher.js</code>文件的<code>addDep</code>()方法中, 在方法的内部会判断当前对象中的<code>depIds</code>对象中, 是否含有传入的<code>dep</code>对象里面存储的 id 值, 如果没有的话, 就会调用<code>observer.js</code>文件中的<code>addSub</code>()方法, 然后把 Watcher 的实例对象传入进去, 然后在<code>observer.js</code>文件中的<code>addSub</code>方法内部, 会把传入进来的 Watcher 实例对象, 存储到<code>dep</code>的对象中的 subs 数组中去, 然后回到<code>watcher.js</code>文件中,然后在该对象的<code>depIds</code>对象中, 然后把<code>dep</code>对象存储的 id 值当作<code>depIds</code>对象的键, 然后把<code>dep</code>对象作为<code>depIds</code>对象的值传入进去。 然后此时就建立了联系</li> <li>联系就有如下几种
<ul><li>一对一的关系: data 数据中只有一个属性, 所有只会创建一个<code>dep</code>对象, 然后模板中只有一个表达式, 也就只会创建一个 watcher 对象, 然后就是一个属性对应一个表达式, 也就是一个<code>dep</code>对象对应一个 watcher 对象</li> <li>一对多的关系: data 数据中只有一个属性, 所有只会创建一个<code>dep</code>对象, 然后模板中有多个表达式, 也就会创建多个 watcher 对象, 然后就是一个属性对应多个表达式, 也就是一个<code>dep</code>对象对应多个 watcher 对象</li> <li>多对一的关系: data 数据中有多个属性, 所有会创建多个<code>dep</code>对象, 然后模板中有一个表达式, 也就只会创建一个 watcher 对象, 然后就是多个属性对应一个表达式, 也就是多个<code>dep</code>对象对应一个 watcher 对象</li> <li>多对多的关系: data 数据中有一多个属性, 所有只会创建多个<code>dep</code>对象, 然后模板中有多个表达式, 也就会创建多个 watcher 对象, 然后就是多个属性对应多个表达式, 也就是多个<code>dep</code>对象对应多个 watcher 对象</li></ul></li></ul> <h4 id="模板解析和事件指令和普通指令"><a href="#模板解析和事件指令和普通指令" class="header-anchor">#</a> 模板解析和事件指令和普通指令</h4> <ul><li>模板: 在<code>Vue</code>中是有模板解析的, 所谓的模板解析, 就是把页面中<code>html</code>模板里使用到的表达式, 解析为真正数据, 并渲染到界面上</li> <li>模板解析其实就是, 在创建<code>Vue</code>实例的时候，通过<code>Compile</code>的对象,保存<code>data</code>数据,然后通过配置对象中的 el 可以获取到页面对应的容器, 如果没有这个容器就会把<code>body</code>作为模板容器, 然后就会在内存当中创建一个虚拟的 DOM 对象(<code>Fragment</code>)也可以叫文档碎片对象,可以高效批量操作 DOM 节点, 然后是在内存当中完成对节点的操作方法。然后这个文档碎片对象就用来保存 div 容器中所有的节点, 然后进入<code>init</code>模板解析的方法,因为虚拟 DOM 对象是一个伪数组, 所以需要转换为真数组, 然后再调用真数组的方法去遍历出来每一个节点, 然后再判断当前的节点是标签节点还是文本节点, 如果当前节点内部还有节点的话, 就会进行递归遍历, 直到当前的节点中没有了子节点</li> <li>判断当前的节点是不是一个文本节点, 并且需要满足插值语法的正则, 如满足就解析插值语法最终会调用<code>bind</code>方法,然后内部会调用<code>updater</code>对象中的相关的方法,进行标签中相关的内容的替换(需要获取<code>vm</code>实例对象及当前这个要替换的表达式的属性的值),</li> <li>如果是标签,则遍历该标签所有的属性,判断该属性是不是指令,然后再去判断这个指令是事件指令还是普通指令</li> <li>如果是事件指令 就是判断属性中是否含有<code>v-</code>开头的指令, 如果有就利用 substring 把<code>v-</code>去除，然后再判断指令是否是事件指令,即含有<code>on</code>, 如果是一个事件指令, 那么就把这个属性进行<code>split</code>按照 : 来切割, 然后取 : 后面的值 剩下的是事件的名字及表达式(该事件对应的回调函数),通过这个表达式去<code>vm</code>中的 methods 中这个方法的代码,然后通过<code>addEventListener</code>方法,为当前的节点绑定事件</li> <li>如果是普通指令,找对应的<code>CompileUtil</code>中的相关的方法,最终执行的是 updater 对象中相关的方法,然后进行替换操作</li> <li>无论是普通指令还是事件指令,最终都要通过 <code>removeAttribute</code> 把标签上的相关属性删除</li> <li>最终会渲染页面</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note_web/chapter4/项目中遇到的问题.html" class="prev">
        项目中遇到的问题
      </a></span> <span class="next"><a href="/note_web/chapter4/源码.html">
        源码解析
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/note_web/assets/js/app.0a8a88e2.js" defer></script><script src="/note_web/assets/js/2.a8152735.js" defer></script><script src="/note_web/assets/js/20.367a78b7.js" defer></script>
  </body>
</html>
