# 源码解析

### 数据代理

- `Vue`中是存在数据代理的, `Vue`的实例对象代理了 data 对象, `Vue`的实例对象是代理者, data 对象是被代理者
- 数据代理实际上就是先是把`Vue`中的配置对象全部传入到`Vue`上,然后把配置对象中的 data, 存放在当前实例的\$data 和\_data 上, 然后通过 Object.keys 的方法, 把 data 中所有的属性利用循环遍历的方法把他们全部取出来, 然后在遍历的过程当中, 找到每一个属性, 然后把遍历出来的属性传入到实现数据代理的方法中, 找到当前`vm`的实例对象, 然后利用`Object.defineProperty`的方法把 data 对象中的每个属性添加到`Vue`的实例对象上, 然后重写整个属性里面的 get 方法和 set 方法, 从而实现数据代理

### 数据的劫持和监视中的`dep`对象和`watcher`的关系

- data 里面叫属性, 模板容器中叫表达式

- data 中有几个属性, 就会创建多少个`dep`对象
- 模板容器中有几个表达式, 就会创建多少个`watcher`对象
- 先会进入 observer(), 然后会根据 data 中有多少属性, 就会创建多少个`dep`对象(id,subs 数组),然后会遍历`vm`实例对象中`data`内的全部属性, 然后全部添加到劫持对象的`data`对象中, 然后重写 get 方法和 set 方法, 然后数据的劫持操作就完成了.
- 数据的劫持操作全部完成之后, `dep`对象也全部创建完毕了, 之后就会进入到`mvvm`的创建模板解析, 然后会进入到 compile 的模板解析的方法, 然后最终都会调用 bind 方法, 然后在 bind 方法的内部会创建新的 watcher 对象(监视对象), 然后会根据模板容器中有多少个表达式就会创建多少个相对应的 watcher 对象
- 当进入到 watcher 构造函数内部的时候, 首先会调用一个 get 方法, 然后会在 Watcher 对象的 getter 属性上调用一个`parseGetter`的函数, 然后该函数会返回一个函数, 然后可以在返回的函数中得到表达式返回的值, 然后因为内部会使用到`vm`实例中的 data 对象中的数据, 所有一定会进入到`mvvm.js`文件中的 get 方法内部, 然后因为`observer.js`文件中重写了 data 对象, 所有也会进入到`observer.js`文件中的 get 方法内部, 在`observer.js`文件中的 get 方法内部, 会调用一个 depend()方法, 这个方法的内部调用了`watcher.js`文件的`addDep()`方法, 然后把`dep`对象传入进去, 此时就开始建立联系了, 然后会进入到`watcher.js`文件的`addDep`()方法中, 在方法的内部会判断当前对象中的`depIds`对象中, 是否含有传入的`dep`对象里面存储的 id 值, 如果没有的话, 就会调用`observer.js`文件中的`addSub`()方法, 然后把 Watcher 的实例对象传入进去, 然后在`observer.js`文件中的`addSub`方法内部, 会把传入进来的 Watcher 实例对象, 存储到`dep`的对象中的 subs 数组中去, 然后回到`watcher.js`文件中,然后在该对象的`depIds`对象中, 然后把`dep`对象存储的 id 值当作`depIds`对象的键, 然后把`dep`对象作为`depIds`对象的值传入进去。 然后此时就建立了联系
- 联系就有如下几种
  - 一对一的关系: data 数据中只有一个属性, 所有只会创建一个`dep`对象, 然后模板中只有一个表达式, 也就只会创建一个 watcher 对象, 然后就是一个属性对应一个表达式, 也就是一个`dep`对象对应一个 watcher 对象
  - 一对多的关系: data 数据中只有一个属性, 所有只会创建一个`dep`对象, 然后模板中有多个表达式, 也就会创建多个 watcher 对象, 然后就是一个属性对应多个表达式, 也就是一个`dep`对象对应多个 watcher 对象
  - 多对一的关系: data 数据中有多个属性, 所有会创建多个`dep`对象, 然后模板中有一个表达式, 也就只会创建一个 watcher 对象, 然后就是多个属性对应一个表达式, 也就是多个`dep`对象对应一个 watcher 对象
  - 多对多的关系: data 数据中有一多个属性, 所有只会创建多个`dep`对象, 然后模板中有多个表达式, 也就会创建多个 watcher 对象, 然后就是多个属性对应多个表达式, 也就是多个`dep`对象对应多个 watcher 对象

### 模板解析和事件指令和普通指令

- 模板: 在`Vue`中是有模板解析的, 所谓的模板解析, 就是把页面中`html`模板里使用到的表达式, 解析为真正数据, 并渲染到界面上
- 模板解析其实就是, 在创建`Vue`实例的时候，通过`Compile`的对象,保存`data`数据,然后通过配置对象中的 el 可以获取到页面对应的容器, 如果没有这个容器就会把`body`作为模板容器, 然后就会在内存当中创建一个虚拟的 DOM 对象(`Fragment`)也可以叫文档碎片对象,可以高效批量操作 DOM 节点, 然后是在内存当中完成对节点的操作方法。然后这个文档碎片对象就用来保存 div 容器中所有的节点, 然后进入`init`模板解析的方法,因为虚拟 DOM 对象是一个伪数组, 所以需要转换为真数组, 然后再调用真数组的方法去遍历出来每一个节点, 然后再判断当前的节点是标签节点还是文本节点, 如果当前节点内部还有节点的话, 就会进行递归遍历, 直到当前的节点中没有了子节点
- 判断当前的节点是不是一个文本节点, 并且需要满足插值语法的正则, 如满足就解析插值语法最终会调用`bind`方法,然后内部会调用`updater`对象中的相关的方法,进行标签中相关的内容的替换(需要获取`vm`实例对象及当前这个要替换的表达式的属性的值),
- 如果是标签,则遍历该标签所有的属性,判断该属性是不是指令,然后再去判断这个指令是事件指令还是普通指令
- 如果是事件指令 就是判断属性中是否含有`v-`开头的指令, 如果有就利用 substring 把`v-`去除，然后再判断指令是否是事件指令,即含有`on`, 如果是一个事件指令, 那么就把这个属性进行`split`按照 : 来切割, 然后取 : 后面的值 剩下的是事件的名字及表达式(该事件对应的回调函数),通过这个表达式去`vm`中的 methods 中这个方法的代码,然后通过`addEventListener`方法,为当前的节点绑定事件
- 如果是普通指令,找对应的`CompileUtil`中的相关的方法,最终执行的是 updater 对象中相关的方法,然后进行替换操作
- 无论是普通指令还是事件指令,最终都要通过 `removeAttribute` 把标签上的相关属性删除
- 最终会渲染页面

### 双向数据绑定

- 当页面发生变化了以后, 会直接进入到`mvvm`的 set 方法中, 和 `observer`的 set 方法, 就会找到相对应的`dep`对象, 然后会判断当前改变的数据的值和之前的值是否相同, 如果相同则不操作, 如果不相同就会把新的值缓存起来, 然后再判断新的值是否为对象, 如果是对象就需要遍历对象中的全部属性, 然后创建相对应的`dep`对象。 然后会调用`dep`的 notify()方法进行遍历`dep`对象中的 subs 数组(watcher 的实例对象), 然后会调用`watcher.js`文件中的`update`方法进行更新操作,然后在 `update`方法中会调用`run`方法, 然后会再次获取新的值, 和旧的值, 然后再次进行判断, 然后如果新值和旧值不一样的话, 就会把新的值缓存到当前 Watcher 的 value 属性身上, 然后会调用 `compile`文件中开始创建 watcher 对象的时候传入的回调函数, 然后再会调用 updater 对象中相对应的方法, 进行文本的替换操作
