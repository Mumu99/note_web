# 常见问题

### DNS 解析

DNS 解析
TCP 连接
发送 HTTP 请求
服务器处理请求并返回 HTTP 报文
浏览器解析渲染页面
连接结束

- 负责将域名地址解析成 IP 地址(4 个缓存, 一个递归查询)
  - 浏览器缓存
  - 计算机缓存
  - 路由器缓存
  - 网络运营商缓存
  - 递归查询, 域名服务器
- 发送请求
  - 按照 HTTP 协议规定, 生成 http 请求的报文, 发送给服务器, 服务器就会按照 http 鞋业规定, 生成 http 响应报文, 发送给客户端
- 浏览器由很多模块组成, HTML 解析模块, CSS 解析模块, JS 引擎等等, 遇到 HTML 代码的时候, 浏览器就会调用 HTML 解析器进行解析, 将 HTML 解析成 DOM 树, 遇到 CSS 代码, 浏览器就会调用 CSS 解析器进行解析, 将 CSS 解析成 CSSOM 树, 遇到 JS 代码的时候, 浏览器就会调用 JS 引擎来解析 js 代码, js 代码就会进行 DOM 操作, 修改 DOM 树, JS 代码也可能会进行 CSS 操作, 就会也修改 CSSOM 树, 然后将 DOM 树和 CSSOM 树结合, 就生成了 render 树, 然后看会对 layout 布局进行计算元素的大小和位置, 然后绘制到页面上。
- 因为 JS 代码修改了 DOM 或 CSS 的时候, 会导致页面的重新布局和绘制, 就会产生重绘重排
- 重绘就是页面发生了变化, 重排就是页面重新布局, 一般就是元素的大小和位置发生改变, 重排一定会导致重绘, 重绘不一定导致重排。
- 在上述的过程当中, 会进行 TCP 的三次握手, 第一次就是浏览器发送给服务器, 告诉服务器这边已及准备好, 会携带 syn 和 seq
- 第二次, 服务器发送给浏览器, 告诉浏览器也准备好了, 需要确认 syn 和 ack 并且也携带 seq
- 第三次, 浏览器发送给服务器, 告诉服务器确认完毕无误, 可以发送请求, 并挈带确认的 ack 和 seq
- seq 就是一个序号, syn 就是发起的新的连接, ack 就是确认的序号

### 为什么三次握手

- 因为客户端和服务器端要进行通信, 3 次握手就证明了双方都有了接收的能力。
- 第一次, 客户端发送网络请求, 服务端收到之后, 服务端就知道客户端是可以发送的, 服务端也是可以接收的
- 第二次, 服务器发送给客户端, 客户端收到了, 这样客户端就知道, 服务器是可以发送的, 客户端也是可以接受的
- 第三次, 客户端发送给服务器端, 这样服务端就能知道, 客户端的接收和服务端的接收都是有效的, 因为第一二次发送的时候, 服务端是并不知道自己发出去的请求是否正常的, 而在第三次的时候, 服务器端接收到了客户端的第二次握手作为响应, 所以服务器端就知道自己和客户端的接收能力都是正常的
- 经过三次握手之后, 服务器和客户端就可以正常的进行通信了

### 什么是 TCP 四次挥手

- TCP 的链接的拆除需要发送四个包, 因此称为四次挥手, 客户端和服务器端都可以主动发起挥手动作
- 第一次主动方发送的时候, Fin+Ack 报文, 并发送序号为 X
- 第二次被动方发送 Ack 报文, 并且发送需要为 z, 然后再确定序号为 x+1
- 第三次被动方发送 Fin+Ack 报文, 并发送序号为 y, 再携带确认序号为 x
- 第四次主动发发送 ack 报文, 并发送序号为 x, 再发送确定序号为 Y

### 为什么建立链接三次握手, 而关闭链接却是四次挥手

- TCP 是双向的, 所以需要在两个方向分别关闭, 每个方向的关闭又需要请求和确认, 所以就四次

### 总结执行上下文以及预解析,变量对象,作用域,闭包等

- 在代码编写完毕之后, 就会确定全局的作用域和局部的作用域, 然后在代码执行之前还未执行的时候, 回出现一个全局的预解析操作, 会提升函数的声明以及var定以的变量名, 之后会创建一个全局的执行上下文环境,然后会把当前的执行上下文环境放入栈中。
- 然后在创建完执行上下文环境之后会创建一个变量对象, 会建立一个类似arguments对象, 用来检查当前上下文中的参数, 然后建立对象属性和属性值的关系, 之后会检查上下文环境中的函数声明, 就是利用function字段声明的函数, 然后在变量对象中以函数名建立一个属性, 属性的值为指向该函数的内存地址引用, 如果在收集的过程当中, 遇到同名的函数, 那么该属性将会被新的引用覆盖掉。然后检查执行上下文中的变量声明, 每找到一个变量的声明, 就会在变量对象中以变量名建立一个属性, 属性值为undefined, 如果该变量名已经存在了, 为了防止同名的函数被修改成undefined, 则会直接跳过, 原来的属性不会被修改了。以及会收集当前this的指向问题。
- 再之后碰到函数的调用, 函数的执行的时候, 在一开始就会确定好作用域, 然后在函数调用的时候, 就出现局部的预解析操作, 收集局部的函数声明以及var定以的变量的提升，接着会创建一个局部的上下文环境, 此时当前的函数也会有一个入栈的操作, 然后会出现局部的变量对象, 也是会建立一个arguments对象, 然后用来收集保存函数的名和引用, 以及变量的名和值。以及确定当前环境的this的指向问题。
- 在函数内部使用数据的时候, 会首先在当前的变量对象中查找是否有需要的数据, 如果没有就会找上层的环境变量对象中是否有该数据, 如果有就使用, 当前环境中的变量对象往上层环境中的变量对象, 直到最顶层的环境中的变量对象中查找, 这个过程就是作用域链的操作方式。它保证了当前执行环境对符合访问权限的变量和函数的有序访问。然后在函数执行完毕之后,其环境生命周期会结束， 会出现弹栈的操作, 但是也不一定会弹栈, 如果当前的函数内部使用到了外部的变量的时候, 此时就会形成闭包, 然后本来该函数执行完毕之后会弹栈出去, 然后js有自动的垃圾回收机制, 会把当前弹栈出去的清除掉, 并释放内存, 但是因为出现了闭包, 就有可能会阻止这个过程。闭包会延迟当前局部变量的生命周期, 可以通过闭包在其他的执行上下文中访问到函数内部的变量。就是因为闭包会延长函数的声明周期, 然后导致内存无法释放, 所以可能会导致内存的溢出和泄露。

​	然后当内部的函数执行完毕之后, 会出现弹栈的操作, 会把当前的执行上下文环境, 弹出去, 然后清除内存空间。再之后, 当全部代码执行完毕之后, 也会把全局的执行上下文环境弹栈出去, 并释放内存空间。

