# 面试总汇

### Vue

1. Vue 的优点及缺点
   1. 首先 Vue 最核心的两个特点，响应式和组件化。
   2. **响应式：**这也就是 vue.js 最大的优点，通过 MVVM 思想实现数据的双向绑定，通过虚拟 DOM 让我们可以用数据来操作 DOM，而不必去操作真实的 DOM，提升了性能。且让开发者有更多的时间去思考业务逻辑。
   3. **组件化：**把一个单页应用中的各个模块拆分到一个个组件当中，或者把一些公共的部分抽离出来做成一个可复用的组件。所以组件化带来的好处就是，提高了开发效率，方便重复使用，使项目的可维护性更强
   4. 虚拟 DOM
   5. 缺点:
      1. 基于对象配置文件的写法，也就是 options 写法，开发时不利于对一个属性的查找
      2. 不利于 seo。
      3. 初次加载时耗时多
2. 谈一谈 Vue 是什么?
   1. Vue 是一个用于构建用户界面的渐进式框架，可以单独的使用 Vue 总的 api，也可以使用 Vue 中的底层服务。Vue 是基于 MVVM 模型的，在起初，前端是直接利用 JS 来操作 DOM 节点，利用浏览器原生的 api，但是由于后来原生的 api 不好用，还需要考虑到兼容性的问题，就引出了 jQuery，然后到后来的 MVC 模型，需要配合服务器，JS 可以在前端修改服务器渲染后的结果，但是，随着前端的页面越来越复杂，用户对于交互的要求也越来越高，要写出比较复杂的页面，光靠 MVC 和 jQuery 是不够的，所以后来就衍生了 MVVM 模型，也就是 Model-View-viewModel，Model 代表数据模型，可以在 Model 中定义数据和修改数据等业务逻辑，View 是视图层，负责将展示数据的，然后 ViewModel 就是用来监听模型数据的改变和控制视图的展示的。然后在 MVVM 中，View 和 Model 是没有直接联系的，都是通过 ViewModel 进行交互, Model 和 ViewModel 之间的交互是双向的，所以视图层的数据变化之后，会同步到 Model 中，而 Model 中的数据发生变化之后，也会同步到 View 视图层，然后 ViewModel 是通过双向数据绑定的方式，将 View 和 Model 层连接起来的。然后 Vue 中是有数据代理的，Vue 的实例对象代理了 data 对象，Vue 的实例对象是代理者，data 对象是被代理者。
   2. 数据代理实际上就是先把 Vue 中的配置对象全部传入到 Vue 中，然后把配置对象中的 data 存在当前实例的\$data 和\_data 上，然后会通过 Object.keys 方法，把 data 中所有属性利用循环遍历的方法全部取出来，然后利用 Object.defineProperty 方法重新 get 方法和 set 方法，就实现了数据代理。然后会添加 watcher 监听数据，一旦数据发生变化之后，watcher 就会调用回调，通知虚拟 DOM 树，哪些变量发生变化了，然后就会经过 diff 算法，会生成一棵新的 DOM 树，然后把新的 DOM 树更新到页面上去，一旦数据发生变化之后，就会调用重写的 set 方法，就能改变 data 里面的数据，从而实现了双向数据绑定。
      diff 算法就是一种优化，用来对比模块之间的差异化，因为真实 DOM 的开销是比较大的，所以就会很大情况下影响到性能，如果我们修改了页面中的某个数据，然后直接渲染到真实的 DOM 中，会引入整个 DOM 树的改变，引起重绘，所以就需要用到 diff 算法，diff 算法就对前后 DOM 树同一层节点进行比较的，只会判断哪些变化了，去更新变化的模块，其他模块全部不会改变。所以在项目中，需要循环的时候就需要加上 key 属性(唯一标识)，比如之前有 ABCD，后来改变成 BCD 了，如果没有 key 唯一标识，diff 算法就会把之前的全部删除，然后再添加 BCD，性能不好，所以给每个元素添加了一个 key 属性只会，diff 算法就会判断是否存在一样的 key，如果有就会保存下来，没有就会移除，就只会去移除 A，不会全部删除，达到高效的使用虚拟 DOM 的效果。
   3. 然后在 vue 中是有模板解析的，所谓的模板解析就是把页面中的 html 模板里面使用到的表达式，解析成真正的数据，并渲染到界面上去，然后模板解析就是在创建 vue 实例对象的时候，会通过 compile 对象，保存 data 数据，然后通过配置对象中的 el 可以获取到页面对应的容器，如果没有容器的话，就会把 body 当成容器，然后就会在内存当中创建一个虚拟的 DOM 对象 Fragement,Fragement 对象也可以叫文档碎片对象，可以高效批量的操作 DOM 节点，然后是在内存当中完成对节点的操作方法。然后就会用 Fragement 来存储 div 容器中的所有节点，然后回进入 init 模板解析的方法，因为 Fragment 是一个伪数组，无法使用真数组的方法，所有就需要转换为真数组然后再调用数组的方法去遍历出来每一个节点
      然后再判断这个节点是标签节点还是文本节点，如果当前的节点内部还有节点的话，就会进行递归遍历，直接无子节点了
   4. 然后判断当前节点是不是文本节点，并且是否满足插值语法的正则，如果满足最终就会调用 bind 方法，然后内部会调用 updater 对象中的相关方法，对标签中的内容进行替换。
      如果是标签节点，那么就会遍历这个标签中的所有属性，再判断该属性是不是一个指令，然后再判断这个指令是事件指令还是普通指令
      如果是事件指令就是判断属性中是否含有 v-开头的指令，如果有利用 substriung 把 v-去除，然后再判断指令是否是事件指令，即有没有含有 on，如果是一个事件执行，那么就会把这个属性进行 split 按照 : 来切割，然后取出 : 后面的值，剩下的是事件的名字，然后通过 addEventListener 方法，为当前的节点绑定相对应事件
      如果是普通指令，就会找到对应的 compileUtil 中的相关方法，最终执行 updater 对象中相关的方法，然后进行替换操作。
   5. 无论是普通指令还是事件指令，最终都要通过 removeAttrbute 把标签上的相关属性删除，最终会渲染页面
3. Vue 的生命周期
   Vue 是有生命周期的，一共有 11 个生命周期，一般开发中常用的生命周期就 8 个，分为 beforeCreate 组件开始创建前，Created 创建后，beforeMount 组件挂载前，Mounted 组件挂载后，beforeUpdate 数据更新前（还没更新），updated 更新后，beforeDestroy 销毁前，destroyed 销毁后，然后因为组件在挂载后才把 Vue 实例挂载上去，然后 DOM 渲染才完全渲染完毕。然后在加载组件的时候，只会执行一次，所以在项目中，一般在 mounted 生命周期中发送封装好的 ajax 请求，获取数据。在项目的开发过程中，可以利用 axios 封装请求拦截器和响应拦截器发送 ajax 请求，在好物社的项目中的登录功能中，在请求拦截器中判断用户的 token 有没有，然后设置请求如果正确就可以登录和访问之前用户浏览过的商品和用户的基本信息。
4. Vue 中的组件通信方式
   Vue 中的组件通信方式有
   props 父子组件之间的通信、在好物社的分类组件中，有一个子组件，就是右边展示数据的组件，然后左边的导航是在分类组件的左侧，然后利用 props 在点击的左侧 nav 导航的时候，然后把当前的下标传入到子级组件内部，然后右边子组件根据父级组件传递过来的数据，进行相对应的数据展示。
   事件总线的方式，在主文件中为 vue 的实例对象身上添加一个$bus，然后可以实现任意组件之间通信问题，需要数据的组件, 监听事件$on 然后加上自定义的事件名，在传递数据的组件, 分发该事件即可\$emit。
   然后还有自定义事件，可以实现任意组件进行通信
   Vuex 进行任意组件进行通信，vuex 是多个组件的共享状态进行集中式的管理，vuex 分为 state 存储数据、getters 从 state 派生的数据，相当于计算属性、mutations 包含多个直接修改状态数据方法的对象，直接修改 state 里面的内容，actions 包含多个简介修改状态数据的方法，然后通过 commit 提交给 mutations 最后由 mutations 去修改 state 里面的状态数据。然后每个方法都对应一个 vuex 的辅助函数，分为 mapState、mapMutations、mapActions、mapGetter。可以在组件内部的计算属性 computed 里面去获取 vuex 中的数据, 也可以在组件挂载的时候，在生命周期 mounted 中使用通过 store.dispatch()分发 Actions.但是这个分开 actions 是异步的操作，返回的是 promise 状态，所以需要配合 ES7 推出的 async+await 配合 promise 使用，因为请求的数据是异步的，然后可能页面加载完毕之后，数据还没请求回来，所以需要用 async+await 但是一般都会定义一个函数再使用 async+await 然后在生命周期 mounted 中调用这个函数来分发 action，不会给生命周期添加 async 和 await，因为容易出现问题。
   PubSub 可以实现任意组件的通信，但是 PubSub 不属于 vue 的
5. Vue 中的路由
   前端路由技术是一种映射的关系，地址和地址对应的组件之间的关系，根据地址不同，在页面中的指定位置可以渲染组件，其实就是一个 a 标签，点击的时候不会跳转，渲染新的内容就是改变相对应路径，然后在 vue 中实先单页面跳转，vue 中实现前端 spa 页面，就会用到 vue-router，然后把需要跳转的地方用 router-link 包裹，然后路由分为声明式路由和编程式路由, 声明式路由不需要 js 代码，直接写在标签上即可，编程式路由，需要 js 代码实现，然后需要配合 router-view 进行路由视图的展示和传递数据，然后路由中分为 hash 模式和 history 模式，hash 模式带#号，history 不带#号，刷新页面可能会出现 404, 因为当操作到分类页面的时候，此时地址栏已经变成了/category 然后当我们刷新的时候。服务器会发送一个/category 的请求, 但是我们打包后只有入口的 index.html 文件, 并没有 cateogy 路径，所以就会报错 404.解决方式可以在 webpack 中的 devServer 中配置 devServer: {historyApiFallback: true}如果请求开发服务器找不到资源的时候，就会重定向到 index.html 文件，当项目上线之后，仍然会出现 404，所以需要在访问静态资源服务器的请求全部以/开头，然后其他的正常请求全部已统一的名字开头，服务器就能通过访问资源的路径来区分是正常的请求还是非正常的请求。然后 hist 模式不存在这个问题，因为浏览器会把#后后面的路径不加载，所以就不存在 404。
6. Vue 中为什么要有 key
   因为不管是 vue 还是 react 都实现了虚拟 DOM，虚拟 DOM 都是有一套 diff 算法的，用来对比模块之间的差异化，因为真实 DOM 的开销是比较大的，所以就会很大情况下影响到性能，如果我们修改了页面中的某个数据，然后直接渲染到真实的 DOM 中，会引入整个 DOM 树的改变，引起重绘，所以就需要用到 diff 算法，diff 算法就对前后 DOM 树同一层节点进行比较的，只会判断哪些变化了，去更新变化的模块，其他模块全部不会改变。所以在项目中，需要循环的时候就需要加上 key 属性(唯一标识)，比如之前有 ABCD，后来改变成 BCD 了，如果没有 key 唯一标识，diff 算法就会把之前的全部删除，然后再添加 BCD，性能不好，所以给每个元素添加了一个 key 属性只会，diff 算法就会判断是否存在一样的 key，如果有就会保存下来，没有就会移除，就只会去移除 A，不会全部删除，就可以实现高效的使用虚拟 DOM
7. computed 和 watch 的区别
   计算属性 computed，是支持缓存，只有依赖数据发送变化的时候，才会重新计算、不支持异步操作，当 computed 内部有异步操作时无效，无法监听数据的变化，computed 属性值会默认走缓存，也就是基于 data 中声明过或者父组件传递过来的 props 中的数据，通过计算属性得到的值，然后计算属性是可以设置 get 和 set 方法的，当访问数据的时候会进入 get 方法，当数据变化的时候会进入 set 方法。
   监听 watch，不支持缓存，数据变化，会直接触发相应的操作，是支持异步操作，监听的函数接受两个参数，一个是最新的值一个是之前的值，监听的数据也必须是 data 中定义的，或者父组件传递过来的，当数据发生变化的时候，触发其他的操作，监听的对象也可以写成字符串的形式，当数据变化的时候，需要执行异步或者开销较大的操作的时候，就使用 watch，如果不是一般用 cpmputed
8. Vue 项目中遇到的问题

   1. 创建 swiper 的时候,无效果,因为创建对象太早了,数据还没请求回来,需要在数据显示之后再创建,利用 watch 和 \$nextTick()
   2. 初始显示异常,就是当我们动态展示数据的时候报错,cannot reade property 'xx' of undefined,原因: 初始值是空对象,内部没有数据,而模块中直接显示 3 层表达式,可以在父级标签中使用 v-if 指令判断 2 层表达式是否存在,即可解决
   3. 更新状态数据,对应的界面不变化, 一般方法给一个已有绑定对象中添加一个新属性,这个属性没有数据绑定,利用 vue.set(obj, 'xx' , value)才有数据

### react

15. Vue 和 React 的异同
    都是动态构建用户界面的，都有虚拟 DOM，内部都是通过虚拟 DOM 提高效率，都有组件化来编写项目，都可以使用 props 实现组件之间的通信，都可以使用脚手架以及构建工具
    vue 是双向数据绑定，react 是单向数据，vue 是对象属性监视实现自动更新，react 是利用 setState 管理数据.
16. react 的 diff
    开发中我们不会将一个节点移动到另外一个节点上, 一开始会利用 tree diff 对比相同层级节点,不同层级的节点不会对比,因为 tree diff 只会对比相同层级节点,不同层级节点不会对比,如果一个节点中有很多的数据,性能还是不好,然后就可以使用 component diff 对比是否是同一个组件,如果是同一个节点,里面的内容就会进行 tree diff,如果不是同一个组件,就会把它标记成需要移除的节点,再继续看下一个节点,再后来就用 element diff ,相同层级节点并且添加了 key 属性,会保留 key 相同的节点,如果有新的节点,就会添加新的节点,如果有不存在的 key 就会移除,比如之前有 ABCD 四个节点,后来经过 compontent diff 之后删除了一个节点变成了 BCD 节点,如果没有 element diff 的话,就会直接把 ABCD 四个节点全部删除,然后再添加 BCD 三个节点,性能不好,如果利用 element diff 就给每个属性添加一个 key 值,然后通过 element diff 的时候,就会判断 key 的值是否相同,不同就移除,新的就添加.性能较好
17. setState 是同步还是异步
    既是同步也是异步,在生命周期函数中,react 事件回调函数中是异步的,多次更新会合并成一次更新(如果更新的数据是相同的,那么就只会在最后一次生效)
    在定时器中,原生 DOM 事件是同步的,同步更新,多次更新会依次同步更新
    setState 使用方法
    this.setState(obj) 只能更新数据,更新用户界面,多次使用,异步情况下会合并
    this.setState(obj, fn) 更新数据,更新用户界面, 后面 fn 函数会在更新页面后触发
    this.setState(p=>{return newState}) 接受上一个 state 状态,返回值是要更新的新状态,多次使用,状态数据会依次更新,页面只会更新一个
18. react 组件的生命周期及钩子
    初始化阶段: componentWillMount
    组件挂载完毕: componentDidMount
    组件完全显示完毕, 在这个生命周期中发生请求,设置定时器,绑定 DOM 事件,因为在 wullmount 中是可能被触发多次的,优先 render,先渲染完页面再发生请求,这样会让页面的渲染速度更快,因为在发送请求的时候,需要操作 DOM 元素就必须在 render 中才能操作
    更新父组件: componentWillReceiveProps: 组件将要接受到新的属性时调用
    组件接受到了新的属性或者新的状态: shouldComponentUpdate
    性能优化的生命周期: pureComponent: 内部实现了对 state 和 props 的浅比较  
    更新数据前: componentWillUpdate
    更新数据后: componentDidlUpdate
    组件销毁时: componenWillUnmount, 请求定时器和取消 ajax 请求等收尾工作

19. 组件间通信方式
    通过 props 可以传递属性和函数,属性由父组件向子组件传递,函数是由子组件向父组件传递,适用于父子组件之间的通信
    使用 redux 进行任意组件之间的通信,集中式管理多个组件共享的状态
    context,用 Provider 标签为后代组件提供数据,用 Consumer 标签进行使用数据
20. redux 的理解
    redux 是一个独立专门用于做状态管理的 js 库,不属于 react 插件库,可以与任何前端库配合使用,但是和 react 配合最佳,它的作用就是集中式管理 react 应用中多个组件共享状态
21. 高阶组件 HOC
    高阶组件就是一个以组件为参数并返回一个新组件的函数,解决代码的重用,比较常见的高阶组件有 redux 和 connect 函数.

### 微信小程序

22. 生命周期函数
    onload
    一个页面只会调用一次,可以在 onload 中获取打开当前页面所调用的 query 参数.
    onshow
    每次打开页面都会调用一次用来显示页面
    onready
    代表页面可以和视图层进行交互
    onHide
    当 navigateTo 或底部 tab 切换时调用
    onUnload
    页面卸载

23. app.json 是对小程序的全局配置
    pages 字段,用来描述当前小程序所有页面路径
    window 字段,小程序的顶部背景色以及文字的颜色等都在这里定义
    tab 字段,小程序全局的 tab 栏

24. wxss 和 css 区别
    wxss 可以书写 rpx 为像素单位,可以使用 import 导入
    wxss 只支持部分 css 选择器

25. 如何提高微信小程序的应用速度?
    提高页面加载速度,可以使用懒加载
    减少默认 data 的大小
    组件化开发

26. 小程序和 H5 的区别
    H5 主要是运行在浏览器, 微信小程序的话运行在非完整的浏览器,是微信开发团队基于浏览器内核完全重构的一个内置解析器,针对小程序专门做了优化,提升了小程序的性能

27. 小程序的双向数据
    小程序里面直接使用 this.data 的书写是不可以同步到视图的,必须调用 this.setData 方法,然后在方法内部才能实现双向数据绑定

28. 小程序的传参
    使用全局变量,就是在 app.js 中实现数据的传递
    可以在跳转或者重定向页面的时候,使用 url 携带参数
    可以使用组件模板 template 传参

29. mpvue
    mpvue 是基于 vue 的一个框架,是由美团出品的,专门开发小程序的框架,还有一个 WePY,但是 WePY 是类似于 Vue 的框架,因为它只是借鉴了 Vue 的开发分格,而 mpvue 就是基于 vue 的,直接使用 vue 写即可.
    mpvue 可以实现组件化开发,然后可以直接写 vue 开发一样,可以利用 webpack 打包工具对项目进行优化,也可以使用 vuex 进行数据管理,还可以使用 npm 去下载外部的依赖,使用脚手架等来开发项目

30. 支付流程
    首先会生成一个商品的订单,然后会调用微信的下单 API,生成一个预付订单,然后预付订单的信息会携带 prepay_id,通过调用支持参数并携带签名,此时才会唤起微信支付功能,会返回相关的支付信息给客户端,当用户点击确认支付的时候,会通过调用 SDK 调用微信支付的接口,然后回发起支付请求,然后服务器会根据支付参数,返回一个需要支付的授权,用户就可以确定支付,输入密码,会提交支付,然后服务器验证完毕只会会完成支付交易,然后回异步的通知支付的结果,根据这个结果通知更新订单状态为已支付,调用查询 API,查询支付结果

### webpack(构建工具)

1. webpack 和 gulp 和 grunt 的区别
   gulp 和 grunt 在早期比较流行,但是在目前来说还是 webpack 用的最多,grunt 和 gulp 是基于任务和流的, 找到一个文件或者类就会进行链式操作,然后会更新链上的所有数据,但是 webpack 是基于入口文件,然后利用不同的 loader 处理不同的文件,还可以使用插件扩展扩展 webpack 的功能

2. webpack 基础
   webpack 是由 entry 入口文件、output 输出文件、loader 加载器、plugins 插件、mode 模式
   entry 入口文件可以是单入口也可以是多入口,单入口就只会输出一个文件, 适用于 spa 页面,多入口就分为 Array / object , Array 只会输出一个文件 / object 会输出多个文件(可以引用在多页面的项目中)
   因为 webpack 本身是只能够识别 json 和 js 模块的,其他模块是不识别的,所有就需要借助于 loader 来帮助 webpack 识别它识别不了的模块
   因为 loader 的功能是有限的,想要更好的优化项目,就需要用到插件
   mode 可以分为开发环境(development)和生产环境(production)

3. webpack 的基本配置
   处理 JS 文件,利用 eslint-lodaer,在 package.json 中配置 eslintConfig 来指示 eslint-loader 需要干什么事情,然后可以设置 enfore: 'pre'优先执行,然后还有 babel-loader 在 package.json 中配置 babel 来指示到底要干什么事情
   处理 Vue 文件,使用到 vue-loader
   处理 JSX 文件,使用 babel-loader 然后配置 presets: ['@babel/preset-react']
   处理 css 文件
   在开发环境中,创建 style 标签插入样式
   需要用到 style-loader\ css-loader\ postcss-loader \ stylus-loader
   在生产环境中,提取单独 css 文件,通过 link 引入
   需要用到 MiniCssExtractPlugin.loader(还需要配置插件 new MiniCssExtractPlugin)
   css-loader\ postcss-loader\ stylus-loader
   url-loader 然后可以设置 limit 来限制文件大小在多少以下会被 base64 进行处理
   处理其他文件(如字体图片\音视频)
   file-loader 就原封不动的输出即可
   可以使用 happypack 启动多进行并发的形式进行 loader 的转换,可以提高打包的速度

4. webpack 优化手段

   1. HMR 热模块替换
      1. 默认情况下,一旦我们修改了代码,全部的代码都会重新的编译,导致速度特别慢
         然后我们希望就是,只更新修改的模块,其他的模块不变,就是实现局部更新,所以就可以使用 HMR 热模块替换的功能, 然后就是在 devServer 中配置 hot: true, 然后使用插件 new webpack.HotModuleReplacementPlugin() 这样就可以 HMR 功能了
         但是默认情况下,HMR 功能只对 style-loader 生效,对 js 是无效的,然后需要开启 js 的 HMR 功能就需要第一种方式,直接在需要引入的 JS 文件的地方, 写 module.hot.accept 然后写模块的路径然后这个 js 文件就会用于 HMR 功能,然后在 vue 中就可以使用 vue-loader 在 react 中就可以使用 react-hot-loader 都会开启 HMR 功能.
   2. cache 缓存
      1. eslint 和 babel 两个任务在处理 js 文件的时候,时间一般会比较长,为了让其重新构建速度更快,就可以使用到 cache 缓存.
         可以在 eslint 的配置中设置 cache: true\ 以及在 babel 的配置中设置 cacheDirectory: true
         然后在设置 cache-loader 的时候,需要放置在 loader 的后面,一般用 cache 缓存都是针对耗时较长的任务,比如 eslint-loader/ babel-loader/ vue-loader 等
   3. oneof
      1. 让模块只被一个 loader 处理,其他的就不看了,能够提升打包的速度,因为很多模块只会用到一个 loader,然后如果这个模块在被打包的时候,以及被一个 loader 处理了,然后还是会一个个 loader 去判断,会拉低打包的速度和效率,所以就需要用到 oneof,但是需要注意的是,写 oneof 的时候,需要把 eslint-loader 放在外部,里面写 babel-loader 因为 js 文件会经过两个 loader 处理.
      2. 可以利用多进程进行打包,在之前利用 happypack,现在一般都用 thread-loader,用法相似,都需要放置在需要使用的 loader 后面, 作用就是可以开启多进程处理前面的任务,提升打包速度,因为每一个进程的开启和通信都是有开销的,所以一般针对开销较大和耗时较长的 babel-loader 是使用.

5. 优化打包代码的体积和性能

   1. 通过调研 webpack 打包优化方案，静态资源体积缩小，优化了用户体验。方案发布后，页面打开速度更快。
   2. 通过引入前端监控方案，能更早定位与发现问题，引入后，让舆情反馈降低了。
   3. 通过引入 node 中间层，实现了前后端之间再一步分离。使得后端接口更微服务化、更专注于功能实现而非页面逻辑，需求迭代更加快速。引入之后，减少了后端开发成本，提高了研发效率。
   4. 兼容性的处理
      1. babel-loader 配置 presets:['@babel/preset-env'] 目前只能编译,转换普通的语法,es6 等复杂的语法不能编译, 然后我就使用了@babel/polyfill 可以做复杂语法的兼容,但是我发现打包之后的体积会很大,所以后来就用了 core-js 然后在@babel/preset-env 的基础上,添加了 useBuiltIns: 'usage'来实现按需加载.
   5. tree shaking 树摇
      1. 作用就是去除无用的 JS 代码,但是必须使用 ES6 模块化才能使用,所以就摇禁止@babel/preset-env 转换成 ES6 模块化语法,就可以设置 modules: false,然后必须要开启 webpack 的生产模式,内部使用 TerserPlugin,用来压缩 JS 代码的插件.最后在 package.json 中配置 sideEffects 来指定哪些文件需要运行 tree diff
   6. code split 代码分割 / lazy loading 懒加载
      1. code split 可以提取公共的代码,拆分多个文件,减少单个文件体积(避免单词请求时间过长)
         利用多入口的方法加上 optimization 实现将 node_modules 抽取成单独的模块,将多入口的公共模块抽取成单独模块
         单入口加 optimization 再加上 import 也可以实现把 node_modules 抽取成单独的模块,动态导入语法 import 就能将某些文件抽取成单独模块,在 vue 中可以使用 import()动态引入一个组件,react 中可以使用 Suspence+lazy 来实现路由组件的动态导入
   7. preload 和 prefetch 预加载
      1. 可以让资源提前加载
         preload 让当前页面使用到的资源加载,但是会在最后加载
         prefetch 让后面要使用到的资源提前加载(当前不需要使用的)
         但是目前兼容性比较差,并且不兼容 sarfai 浏览器
   8. hash
      1. webpack 每次构建都会生成一个新的并且唯一的 hash 值,只要 webpack 重新构建,所有文件的 hash 都会发生变化,缓存就会失败,然后后来就用 chunkhash,打包属于同一个 chunk,就共享一个 hash,但是样式文件被 css-loader 打包 js 文件中,导致样式和 js 文件属于同一个 chunk,共享一个 hash,一旦样式文件发送变化,js 文件也会跟着变化.也不好,后来我又换成了 contenthash,根据文件的内容来定义 hash,所以只要文件内容不一样,hash 就不一样.比如 A 模块有一个依赖,是 B 模块,那么 A 模块内部就会保存 B 模块的 hash 值,一旦 B 模块发送变化之后,B 模块的 hash 值就会发送变化,导致 A 模块内部保存 B 模块 hash 值也发送了变化,此时 A 模块文件内容发送变化,它的 hash 值也会变化,然后去官网上查找资料发现可以利用 rentimechunk: true 将 A 模块保存的 B 模块 hash 值存在 runtime 文件中,这样 A 模块内部就没有 B 模块的 hash 值了, 就不会因为 B 模块的修改而修改
   9. PWA 渐进式网络应用程序
      1. 让我们开发的项目,即使离线也可以访问, 内部使用了 service worker + cache 实现的,具体需要借助 workbox-webpack-plugin 来实现
         JS 高级

### JS

1. null 和 undeined 的区别
   1. null 表示无，就是没有，而 undefined 是未定义
   2. 在转为数字的结果不同，Number(null)是 0，而 undefined 是 NAN
2. 什么情况下出现 undefined
   1. 变量声明为赋值
   2. 函数调用时，应提供的参数没有提供
   3. 对象没有赋值属性
   4. 函数没有返回值，默认返回 undefined
3. 冒泡排序和数组去重
   1. 冒泡
      function bubbleSort (arr) {
      for (let i = 0; i < arr.length; i++) {
      let flag = true;
      for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
      flag = false;
      let temp = arr[j];
      arr[j] = arr[j + 1];
      arr[j + 1] = temp;
      }
      }
      if (flag) break;
      }
      return arr;
      }
   2. 数组去重
      1. Array.from(new Set(arr))
      2. [...new Set(arr)]
      3. 利用 for 循环嵌套

4) 数据类型

   1. 基本数据类型: Number\string\undefined\null\boolean\symbol\bigint
   2. 引用类型: Object \ function \ array

5) 执行上下文 \ 预解析 \ 变量对象 \ 作用域 \ 作用域链 \ 闭包

   在我们代码编写完毕之后,就会确定好全局的作用域和局部的作用域,然后在代码执行之前还未执行的时候,会出现一个全局的预解析操作, 会提升函数的声明以及 var 定义的变量名, 之后会创建一个全局的执行上下文环境, 然后会把当前执行上下文环境放入栈中
   然后在创建完执行上下文环境之后会创建一个变量对象 scope,会建立一个类似 arguments 对象,用来收集 function 字段声明的函数, 然后在变量对象中以函数名建立一个属性,属性的值就是该函数在内存地址的引用,如果在收集的过程当中,遇到了同名的函数,那么该属性将会被新的引用覆盖掉,然后会检查执行上下文中变量声明, 找到每一个变量声明,就会在变量对象中建立一个属性,属性的值为 undefined,如果该变量名已经存在了的话,为了防止同名的函数被修改成 undefined, 则会直接跳过,原来的属性不会被修改,还会确定当前 this 的指向.
   再往后运行,碰到函数的调用,会出现局部的预解析操作,也是收集局部函数的声明以及 var 定义的变量的提升, 然后会出现一个局部的执行上下文环境,然后此时就会把局部的上下文环境放入栈中,然后也会创建变量对象,收集保存函数的名以及引用,以及变量名和值,以及确定 this 的指向问题
   在函数内部使用数据的时候,会首先在当前的变量对象中查找是否有需要的数据,如果没有就会找上一层的变量对象中是否有该数据,如果有就会使用上层的数据,如果还是没有就会一直往上层的变量对象中查找,直到找到全局的变量对象中,如果还是没有,就会报错,xxx is not defined,这个过程就是作用域链,然后在内部函数执行完毕之后,其环境生命周期就会结束,就会出现弹栈的操作, 但是也不一定会弹栈, 如果当前函数内部使用到了外部的变量的时候, 此时就会形成闭包,然后本该执行完毕之后弹栈出去然后 js 的垃圾回收机制清楚掉,但是因为出现了闭包,就会阻止掉这个过程,闭包会延长当前局部变量的生命周期,可以通过闭包在其它的执行上下文中访问到内部的数据, 就是因为闭包的特性,延长局部变量的生命周期,可能会导致内存的溢出和泄露
   然后当内部的函数执行完毕之后, 会出现弹栈的操作,会把当前的执行上下文环境弹出去,然后清楚内存空间, 再等全部代码执行完毕之后,会把全局的执行上下文环境也弹栈出去,并释放内存空间

6) 原型

   1. 原型指的就是原型对象, 原型就是对象,js 中原型一共有两个, 一个显示原型 prototype,一个隐式原型**proto**, prototype 是浏览器的标准属性,是给程序员使用的,相似原型存在函数中,**proto**浏览器的非标准属性,浏览器使用的,隐式原型,存在实例对象中,函数中有 prototype,实例对象中**proto**, 函数也是对象,只要是对象就会有**proto**,无论是构造函数还是普通函数,或者方法,只要是函数,就一定会有 prototype
   2. 原型的作用可以共享数据,节省内存空间, 可以实现 js 中的继承,原型对象中的方法是可以相互调用的(在同一个原型对象上)
   3. 实例对象一般都是通过构造函数进行创建的, 一开始会在内存中申请一块空闲的空间,用来存储实例对象, 设置 this 为当前的实例对象,然后初始化实例对象中的属性和方法的值,把 this 作为当前对象进行返回

7) 原型链:

   1. 每个函数中都是 prototype,每个对象中都是**proto**, 实例对象中的**proto**指向的当前构造函数的 prototype,
   2. 所有的 prototype 都是一个对象,所以内部也有**proto**, 普通函数的 prototype 中的**proto**指向的是 Object.prototype.
   3. 每一个函数都是 Function 的实例对象,所以函数对象中的**proto**指向的都是 Function 的 prototype,
   4. 因为 Object 也是构造函数,函数也是对象,所以 Object 的**proto**也是指向 Function 的 prototype
   5. Function 这个构造函数也是对象,所以里面的**proto**也是指向 Function 的 prototype
      Object 的**proto**指向的 null

8) nextTick 实现原理
   1. nextTick 在下次 DOM 更新循环结束之后执行延迟回调吗,在修改数据之后立即使用这个方法,获取最新的 DOM,就需要说到 js 的事件轮询机制了,因为 js 执行的单线程,然后 nextTick 是基于事件循环的,所以同步的任务都在主线程上执行,形成一个执行栈,主线程之外会存在一个任务队列,只要异步任务有结果就会在任务队列中放置一个事件,然后当同步任务全部执行完毕之后,就会读取任务对象,那些对应的异步任务,会结束等待状态,进入执行栈中执行. 然后主线程会不断的读取任务队列中是否有完成的异步,有就会执行.然后 Vue DOM 的更新是异步执行的,即修改数据时,视图不会立即更新,而是会监听数据变化,并缓存在同一事件循环中,等同一数据循环中的所有数据变化完成之后,再统一进行视图的更新,然后 nextTick 就是为了确保得到更新后的 DOM 的.然后 nextTick 首先就回把回调函数放入到 callbacks 等待执行,然后将执行函数放到微任务或者宏任务,执行函数依次执行 callbacks 中的回调,因为 mirotask 的优先级高,能够确保队列中的微任务在一次事件循环前被执行完毕,然后 nextTick 返回的是一个 promise 对象,然后考虑到兼容性问题, 如果浏览器不支持 promise 就回用 microtask 进行降级处理,会用 setTimeout 为 0 代替异步执行.

9.  react 路由和 vue 路由的区别

    1.  vue 有路由守卫,react 没有路由守卫
    2.  vue 中有路由缓存 keep-alive, react 中没有
    3.  vue 中路由的传参方法比较多, 多了 meata 和 props 传参方法
    4.  属性不一样, vue($route\$router), react(location\match\history)
    5.  route 是当前路由信息, 可以获取到当前路由地址参数等
    6.  router 是全局路由实例对象, 可以通过 router 进行路由的跳转后退等

10. cookie、session 对比

    1.  cookie 和 session 区别
    2.  cookie 数据存在客户端,session 的数据存在服务器
    3.  cookie 本身并不安全, 考虑到安全应当使用 session
    4.  session 会在一定时间内保存在服务器上,如果访问量比较大,会消耗服务器的性能,考虑到减轻服务器性能方法的开销,就使用 cookie
    5.  cookie 保存的数据不能超过 4k,很多浏览器都会限制一个域名最多保存 50 个 cookie,可以将登录信息等重要信息存在 session 中,其他信息需要保留可以放在 cookie 中

11. localStorage 和 sessionStorage 的区别

    1.  因为在 web 本地存储的场景中,cookie 的使用会受到限制,容量小,数据无法持久化保存
    2.  然后在 H5 的标准中,出现了 localStorage 和 sessionStorage
    3.  cookie 保存在内存当中,浏览器关闭就会失效,如果设置了过期时间,在到期后也会失效,并却容量只有 4kb
    4.  localStorage,理论上是永久有效的,除非手动删除,然后存储空间为 4.98mb,但是在 safari 浏览器里面只有 2.49mb, 保存在客户端中,不和服务器交互,节省网络流量
    5.  sessionStorage,仅在当前的网页会话下有效,关闭页面或者关闭浏览器都会失效,大小也是 4.98mb
    6.  然后一般在开发过程中,就会把用户的登录信息存在 local Storage 中

12. 谈谈 ES6
    1. ES6 是 2015 年推出 JS 语法规范, 也是目前开发中使用很多的一个规范
    2. 内容包括一些简单语法:
       1. 定义变量 let / 定义常量 const
       2. 对象数组的解构赋值
       3. 三点运算符
       4. 模板字符串等
    3. 也有一些比较复杂的语法
       1. 箭头函数(箭头函数是没有 this 的，它的 this 指向是最近一层的 this 指向)
          1. this 的指向是函数调用的时候才会动态确定的
          2. 普通函数直接调用 this 指向 winfow，在 ES5 严格模式下, this 指向 undefined
          3. 普通函数隐式调用(obj.fn()) 指向 obj
          4. 普通函数显式调用，利用 call,apply,bind 指向 obj
          5. 普通函数 new 调用，指向创建出来的实例对象
          6. 在回调函数中，定时器的回调，指向 window，ES5 严格模式下指向 undefined，在 DOM 事件普通回调函数中 指向被绑定的 DOM 元素
          7. 在框架中，Vue 中，指向 vm 实例对象， 在 react 中，普通类组件指向 undefined， 在 react 的生命周期函数中，this 指向组件实例对象
       2. Promise
          1. 是一个异步编程，解决回调地狱(回调函数的嵌套)的方案，内部有三个状态，分别的 pending 初始化状态，resolve 成功状态，reject 失败状态， 当调用 resolve 的时候，promise 的状态会从 pending 状态变成 resolve 状态，调用 reject 的时候，pending 状态也会变成 reject。状态只能改变一次
          2. 使用 new Promise(), 传入一个函数作为参数， 函数中执行异步代码，当异步代码成功，就调用 resolve 方法，并把成功的结果返回出去，失败就调用失败的方法，把失败的原因也返回出去，外部通过 new Promise()产生的实例对象 promise 绑定 then/catch 方法分别捕获成功和失败状态
          3. Promise A+原理
             1. resolve 功能就是将 pending 变成 resolved，并返回成功结果，内部判断当前状态是否是 pending 状态，目的就是为了保证状态只能改变一次，是的话就改变状态值和添加结果值，同时异步调用成功的回调函数
             2. reject 功能就是将 pending 变成 rejected，并返回失败结果，内部判断当前状态是否是 pending 状态，目的就是为了保证状态只能改变一次，是的话就改变状态值和添加失败的原因，同时异步调用失败的回调函数
             3. then 方法就是内部会返回一个新的 promise 对象(目的是为了链式调用)，然后绑定 then 方法的 promise 添加了成功回调和失败回调，一旦绑定了 then 方法的 promise 变成成功状态，就会异步调用成功回调，一旦绑定了 catch 方法的 poromise 变成失败状态，就会异步调用失败回调，当异步调用成功的回调的时候，内部就会调用 then 方法传入的第一个回调，并根据返回值来决定 then 方法内部返回新的 promise 的状态，当异步调用失败回调的时候，就会调用 then 方法传入的第二个回调，并根据返回值来决定 then 方法内部返回 promise 的状态。然后 then 方法内部返回新的 promise 的状态分为三种情况，第一种情况，如果返回值是 promise，就根据 promise 对象的状态来改变，如果返回值不是 promise 就是成功状态，如果函数调用时报错，就是失败状态，然后可以利用 try{}catch(){}来捕获错误
       3. async--> ES8
          1. async 定义函数，await 等待 promise 对象的执行结果，如果是成功状态程序就往下执行，如果是失败状态，async 就会中断执行，如果 async 函数绑定 then/catch 就触发 catch 的回调，如果没有绑定，就会报错
          2. async 函数代码还没执行完，返回值是 pending 状态，全部执行完毕是成功状态，一旦报错就是失败状态
          3. 在项目中使用 async 和 promise 解决回调地狱的问题

### 从 url 输入地址到最终渲染中间发生了什么

1. DNS 解析
   1. 负责将域名地址解析成 IP 地址(4 个缓存，一个递归查询)
      1. 浏览器缓存
      2. 计算机缓存
      3. 路由器缓存
      4. 网络运营商缓存
      5. 递归查询，域名服务器
2. TCP 连接
   1. 要进行 TCP 三次握手
      1. 第一次浏览器携带 syn 发送给服务器，告诉服务器准备好了
      2. 第二次是服务器携带 syn + ack 发送给客户端， 告诉客户端我也准备好了
      3. 第三次就是浏览器携带 ack 确认之前的数据都没有改变，然后告诉服务器确认完毕，就建立了 TCP 连接
3. 发生 HTTP 请求
   1. 浏览器将请求报文发送给服务器
4. 服务器处理请求并返回 HTTP 报文
   1. 服务器将响应的结果返回给浏览器
5. 浏览器解析渲染页面
   1. 调用 html 解析器将 html 解析成 DOM 树
   2. 调用 css 解析器将 css 解析成 CSSOM 树
   3. 调用 js 解析器解析 js 代码
      1. 如果修改了 DOM 节点，就会重新解析 DOM 树
      2. 如果修改了 CSS 节点，就会重新解析 CSSOM 树
   4. 会将解析好的 DOM 树和 CSSOM 树结合成 render 树
   5. layout 进行渲染
   6. render 进行渲染
6. 连接结束
   1. TCP 四次挥手
      1. 第一次浏览器发送给服务器，告诉服务器请求报文发送完毕
      2. 第二次服务器发送给浏览器，告诉浏览器请求报文接受完毕，等待断开
      3. 第三次服务器发送给浏览器，告诉浏览器响应报文发送完毕
      4. 第四次浏览器发送给服务器，告诉服务器响应报文接受完毕，可以断开
      5. 然后服务器断开连接，再是浏览器断开连接
7. 为什么建立连接是三次，关闭却是四次
   1. TCP 是双向的，所以需要两个方向分别关闭，每个方向关闭又需要请求和确认，所以就四次

### HTML

1. DIV+CSS 布局的好处

   1. 代码简介，且结构和样式分离，易于维护
   2. 代码量减少，减少大量的带宽，页面加载速度更快，提高用户的体验
   3. H5 提供的语义化标签，对 SEO 更加友好
   4. 符合 W3C 的标准，保证网站不会因为网络应用的升级而被淘汰

2. 如何解决 a 标点击后 hover 事件失效的问题?

   1. 改变 a 标签 css 属性的排列顺序
   2. link→visited→hover→active

3. 点击一个 input 依次触发的事件

   1. onmouseenter 、 onmousedown 、 onfocus 、onclick

4. 响应式的好处
   1. 对某些数据的修改就能自动更新视图，让开发者不用再去操作 DOM，有更多的时间去思考业务逻辑。

### 为什么会出现跨域问题?

1. 违背同源策略
   1. 域名
   2. 协议名
   3. 端口号
2. 解决方案
   1. jsonp
      1. 利用 scipt 不存在跨域, 所有会利用 script 去发送请求, 但是只能发送 get 请求
   2. cors
      1. 利用设置响应头字段来解决
      2. Access-Control-Allow-Origin
      3. Access-Control-Allow-Methods
      4. Access-Control-Allow-Age
      5. Access-Control-Max-Age
      6. 进阶
         1. 预检请求: Options
         2. 客户端不知道当前请求是否可以跨域，所以在发送真正请求之前，之前发送一个请求方式为 options 的预检请求来判断当前请求是否可以跨域，如果预检请求返回结果标识可以跨域，才会真正发送请求，如果不行，就不发送请求了
         3. 可以利用 Access-Control-Allow-Credentials:true
         4. 因为每次请求之前都会发预检请求，性能不好，所以就可以通过 Access-Control-Allow-Age 来缓存预检请求的结果，在缓存有效期内不会再发送预检请求
