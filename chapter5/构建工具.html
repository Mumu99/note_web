<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>构建工具 | note_web</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="shortcut icon" type="image/x-icon" href="./images/favicon.ico">
    <meta name="description" content="熊木木出版">
    
    <link rel="preload" href="/note_web/assets/css/0.styles.7cc68753.css" as="style"><link rel="preload" href="/note_web/assets/js/app.0a8a88e2.js" as="script"><link rel="preload" href="/note_web/assets/js/2.a8152735.js" as="script"><link rel="preload" href="/note_web/assets/js/25.c8dbb4c7.js" as="script"><link rel="prefetch" href="/note_web/assets/js/10.0b7deae7.js"><link rel="prefetch" href="/note_web/assets/js/11.b28cb736.js"><link rel="prefetch" href="/note_web/assets/js/12.1e24d268.js"><link rel="prefetch" href="/note_web/assets/js/13.6a7dc0b8.js"><link rel="prefetch" href="/note_web/assets/js/14.5ebcae47.js"><link rel="prefetch" href="/note_web/assets/js/15.361aa7de.js"><link rel="prefetch" href="/note_web/assets/js/16.d753cdbb.js"><link rel="prefetch" href="/note_web/assets/js/17.aad2eb09.js"><link rel="prefetch" href="/note_web/assets/js/18.fb79d12c.js"><link rel="prefetch" href="/note_web/assets/js/19.b0404afa.js"><link rel="prefetch" href="/note_web/assets/js/20.367a78b7.js"><link rel="prefetch" href="/note_web/assets/js/21.2c0d84e8.js"><link rel="prefetch" href="/note_web/assets/js/22.58f449fc.js"><link rel="prefetch" href="/note_web/assets/js/23.fe2549f8.js"><link rel="prefetch" href="/note_web/assets/js/24.7fe34f57.js"><link rel="prefetch" href="/note_web/assets/js/26.49c63d2e.js"><link rel="prefetch" href="/note_web/assets/js/27.65899db2.js"><link rel="prefetch" href="/note_web/assets/js/28.9363e098.js"><link rel="prefetch" href="/note_web/assets/js/29.aebf9855.js"><link rel="prefetch" href="/note_web/assets/js/3.03f151d4.js"><link rel="prefetch" href="/note_web/assets/js/30.5dab8d40.js"><link rel="prefetch" href="/note_web/assets/js/4.d5e2826f.js"><link rel="prefetch" href="/note_web/assets/js/5.9499be40.js"><link rel="prefetch" href="/note_web/assets/js/6.153d8ea2.js"><link rel="prefetch" href="/note_web/assets/js/7.2aac5bdb.js"><link rel="prefetch" href="/note_web/assets/js/8.84af4e42.js"><link rel="prefetch" href="/note_web/assets/js/9.747e23d2.js">
    <link rel="stylesheet" href="/note_web/assets/css/0.styles.7cc68753.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/note_web/" class="home-link router-link-active"><img src="/note_web/images/logo.png" alt="note_web" class="logo"> <span class="site-name can-hide">note_web</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/note_web/chapter1/html.html" class="nav-link">
  H5
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JS" class="dropdown-title"><span class="title">JS</span> <span class="arrow down"></span></button> <button type="button" aria-label="JS" class="mobile-dropdown-title"><span class="title">JS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note_web/chapter2/初级Js.html" class="nav-link">
  普通
</a></li><li class="dropdown-item"><!----> <a href="/note_web/chapter2/高级Js.html" class="nav-link">
  高级
</a></li></ul></div></div><div class="nav-item"><a href="/note_web/chapter3/移动端相关.html" class="nav-link">
  移动端
</a></div><div class="nav-item"><a href="/note_web/chapter4/基础使用.html" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/note_web/chapter6/常见问题.html" class="nav-link">
  常见问题
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/note_web/chapter1/html.html" class="nav-link">
  H5
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JS" class="dropdown-title"><span class="title">JS</span> <span class="arrow down"></span></button> <button type="button" aria-label="JS" class="mobile-dropdown-title"><span class="title">JS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note_web/chapter2/初级Js.html" class="nav-link">
  普通
</a></li><li class="dropdown-item"><!----> <a href="/note_web/chapter2/高级Js.html" class="nav-link">
  高级
</a></li></ul></div></div><div class="nav-item"><a href="/note_web/chapter3/移动端相关.html" class="nav-link">
  移动端
</a></div><div class="nav-item"><a href="/note_web/chapter4/基础使用.html" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/note_web/chapter6/常见问题.html" class="nav-link">
  常见问题
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/note_web/笔记指南.html" class="sidebar-link">笔记指南</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>一.H5</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note_web/chapter1/h5.html" class="sidebar-link">H5</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>二.JS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note_web/chapter2/初级Js.html" class="sidebar-link">初级 Js</a></li><li><a href="/note_web/chapter2/高级Js.html" class="sidebar-link">高级 Js</a></li><li><a href="/note_web/chapter2/自定义call-apply-bind方法.html" class="sidebar-link">自定义 call 和 apply 和 bind 方法</a></li><li><a href="/note_web/chapter2/ECMAScript.html" class="sidebar-link">ECMAScript</a></li><li><a href="/note_web/chapter2/node.html" class="sidebar-link">NodeJS</a></li><li><a href="/note_web/chapter2/git.html" class="sidebar-link">Git</a></li><li><a href="/note_web/chapter2/ajax.html" class="sidebar-link">AJAX</a></li><li><a href="/note_web/chapter2/git常用指令.html" class="sidebar-link">git 常用指令</a></li><li><a href="/note_web/chapter2/模块化.html" class="sidebar-link">模块化</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>三.移动端</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note_web/chapter3/移动端相关.html" class="sidebar-link">移动端相关</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>四.Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note_web/chapter4/基础使用.html" class="sidebar-link">基础使用</a></li><li><a href="/note_web/chapter4/项目中遇到的问题.html" class="sidebar-link">项目中遇到的问题</a></li><li><a href="/note_web/chapter4/vue面试.html" class="sidebar-link">vue 面试</a></li><li><a href="/note_web/chapter4/源码.html" class="sidebar-link">源码解析</a></li><li><a href="/note_web/chapter4/vue扩展.html" class="sidebar-link">Vue 扩展</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>五.webpack</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note_web/chapter5/构建工具.html" class="active sidebar-link">构建工具</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/note_web/chapter5/webpack总结.html" class="sidebar-link">总结 Webpack</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>六.常见问题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note_web/chapter6/常见问题.html" class="sidebar-link">常见问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>七.React</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note_web/chapter7/react面试.html" class="sidebar-link">react 面试</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>八.小程序</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note_web/chapter8/小程序面试.html" class="sidebar-link">小程序面试</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>九.面试总汇</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note_web/chapter9/面试总汇.html" class="sidebar-link">面试总汇</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="构建工具"><a href="#构建工具" class="header-anchor">#</a> 构建工具</h1> <h3 id="webpack和grunt、gulp的不同"><a href="#webpack和grunt、gulp的不同" class="header-anchor">#</a> webpack和grunt、gulp的不同</h3> <ul><li>三个都是前端的构建工具, grunt和gulp在早期的话比较流行, 但是在目前来说, webpack是用的最多的, grunt和gulp是基于任务和流的, 就类似于jQuery, 找到一个文件或者类, 就一系统的链式操作, 然后更新链上的所有数据, 整条链就构成了一个任务, 多个任务就构造出整个的web构建流程。</li> <li>但是weboack是基于入口文件的, webpack会自动的递归解析入口所需要加载的全部资源, 然后用不同的Loader来处理不同的文件, 然后还可以使用Plugin来扩展webpack的功能</li></ul> <h3 id="常见的loader有哪些-怎么解决问题的"><a href="#常见的loader有哪些-怎么解决问题的" class="header-anchor">#</a> 常见的Loader有哪些, 怎么解决问题的</h3> <ul><li>loader是webpack的核心, 用于对模块的源代码之间进行转换, loader是支持链式调用的, 从右至左, 同时也支持同步和异步</li> <li>file-loader: 把文件输出到一个文件夹中, 在代码中通过url去引用输出的文件</li> <li>url-loader: 和file-loader相似, 但是能在文件很小的情况下, 以base64的方式把文件内容写进代码中</li> <li>css-loader: 允许将css文件通过require的方式引入，并返回css代码</li> <li>less-loader: 处理一些less文件</li> <li>sass-loader: 处理sass文件</li> <li>postcss-loader: 可以处理样式文件的兼容性问题, 但是默认情况下只能做一些css兼容性处理, 但是不够全, 所有还需要将package.json中配置, 然后就可以实现样式的兼容性</li> <li>html-minify-loader: 压缩HTML文件</li> <li>babel-loader:
<ul><li>把ES6的语法会自动的转换成ES5, 可以用来处理js的兼容性问题, 因为浏览器的版本以及不同浏览器之间, 解析的js方式不同, 所以就需要利用babel来配置js的兼容性问题, 但是只能将一些普通的ES6语法转换成ES5语法,一旦一些复杂的语法, 在IE浏览器中的, 如Promise,Async等就不会转换, 就会报错, 所以就可以在入口文件js引入@babel/polyfill, 然后会将所有的ES6语法解析成ES5的语法, 然后可以兼容各种浏览器, 但是因为他是把所有的ES6代码都解析成了ES5, 有些我们没有用的也解析了, 所以代码的体积会变的很大, 就可以利用core-js来解决这个问题, 然后在入口的js文件中也不需要引入@babel/polyfill, 只需要在loader中配置即可, 然后就是当我们的代码写的哪些ES6, 就只会解析我们所写的, 不会全部解析ES6语法。</li></ul></li> <li>style-loader: 操作样式</li> <li>eslint-lodaer: 通过ESlint来检测代码规范</li></ul> <h3 id="有哪些常见的plugin-他们是解决什么问题的"><a href="#有哪些常见的plugin-他们是解决什么问题的" class="header-anchor">#</a> 有哪些常见的Plugin？他们是解决什么问题的</h3> <ul><li>因为很多东西靠loader来解决是完全不够的, 所有就有了Plugin(插件), 就是用来解决loader无法解决的事情。</li> <li>Plugin是一个独立的模块, 模块对外面暴露一个js函数, 函数的原型(prototype)上定以一个compiler对象的apply方法, apply函数中需要有通过compiler对象挂载的webpack事件钩子, 钩子的回调中能拿到当前编译的compilation对象, 如果是异步编译插件的话, 就可以拿到回调callback, 完成自定义子编译流程并处理complition对象的内部数据, 如果是异步的话, 就要等数据处理完成后执行callback回调</li> <li>web-webpack-plugin: 方便为单页面应用输出</li> <li>happypack: 启动多进程并发进行loader的转换, 可以提高打包的速度</li> <li>hot-module-replacement-plugin:
<ul><li>开启热模块替换功能, 简称HMR, 因为在默认的情况下, 改动一个文件, 会引起整个web程序的刷新, 会全部重新打包, 性能不好, 然后可以利用HMR来实现,改动一个文件, 只更新这一个文件, 其他的不变(性能好), 首先就想要引入webpack然后在添加插件, 并且需要在server中写hot:true, 这样就能实现HMR功能, 但是因为HMR功能默认是在样式文件下生效, 我们需要在js中也生效的话, 就需要在入口的js文件中判断, 有没有开启HMR功能, 如果有开启, 就利用module.hot.accept为需要开启HMR功能的js文件进行开启。这样就能实现, 样式和JS都可以用到HMR功能了, 这样就可以优化性能, 提高程序的运行速度, 提高效率.</li></ul></li> <li>webpack-spritesmith:
<ul><li>用插件制作雪碧图, 就是在开发代码的时候, 会有很多的小图标之类的, 一般这些小图标都是png格式的透明背景图片, 一般用于按钮以及其他元素中, 一般小图标都会有很多个, 虽然体积不大, 但是每用到一次都会发送一次请求, 如果图片多的话, 会占用服务器的内存, 以及占用请求的通道, 因为浏览器的http请求个数是有限的, 会浪费掉请求资源, 我们就可以把多个小图标整合到一张图片中, 然后再利用c3的background-postion来实现, 最后在页面中进行渲染操作, 这样就只发送了一次请求, 即使在别的地方也用到改图片, 也不会再发送请求了, 因为浏览器已经把图片缓存下来了. 因为上述的功能做起来比较麻烦, 需要和UI沟通, 然后需要测量图片的大小以及位置, 然后还要写特定的css, 所有在webpack中的这个webpack-spritesmith插件自动把每一个小图标生成一张大图, 多个http请求变成一个, 然后会自动的测量大图中每个小图标的位置, 帮我们生成对应的css文件.</li></ul></li></ul> <h3 id="webpack的构建流程是什么"><a href="#webpack的构建流程是什么" class="header-anchor">#</a> webpack的构建流程是什么</h3> <ol><li>初始化参数: 从配置文件和shell语句中读取和合并参数, 得出最终的参数</li> <li>开始编译: 用初始化参数得到的Compiler对象, 加载所有的配置的插件, 执行对象的run方法然后开始执行</li> <li>确定入口文件: 会找到配置中的entry找到所有的入口文件, 入口文件可能是单个, 也可能是多个</li> <li>编译模块: 从入口文件出发, 调用所有配置的Loader对模块进行编译, 再找出该模块依赖的模块, 再递归查找, 直到所有的依赖文件全部编译</li> <li>完成模块编译: 在经过Loader翻译完后, 得到了每个模块被编译后的最终内容以及依赖关系</li> <li>输出资源: 根据入口文件和模块之间的依赖关系, 组装成一个个包含多个模块的Chunk, 再把每个Chunk转换成一个单独的文件加入到输出的列表中来, 到这个地方是修改输出内容的最后机会</li> <li>完成输出: 在确定好输出的内容后, 根据配置确定输出的路径和文件名, 把文件内容写入到文件系统</li></ol> <h3 id="如何利用webpack来优化前端性能-提高性能和体验"><a href="#如何利用webpack来优化前端性能-提高性能和体验" class="header-anchor">#</a> 如何利用webpack来优化前端性能？（提高性能和体验）</h3> <ul><li><p>压缩代码, 删除多余的代码, 注释, 简化代码的写法等, 任何利用webpack的UglifyJsPlugin,ParallelUglifyPlugin来压缩JS文件, 利用MiniCssExtractPlugin来压缩css文件</p></li> <li><p>利用CDN加速, 在构建过程中, 讲引用的静态资源路由修改喂CDN上对应的路径, 可以利用webpack对应putput参数和loader的publicPath参数来修改资源路径</p></li> <li><p>tree shaking去除无用代码:</p> <ul><li>树摇, 就是将文件中没有使用到的代码, 不会编译. 因为在有时候, 我们调用的代码有些地方用不到, 然后webpack还是会打包进去, 这样文件的体积就会变大, 但是编写代码的时候, 必须使用ES6模块化, 然后得使用webpack production生产环境, 如果使用到了babel的话, 就要设置modules: false, 以为@babel/preset-env会自动将ES6模块化, 转换成commonJs,设置了modules:fasle, 就不会转换为commonjs, 还需要在package.json文件中配置sideEffects: false, 就可以把所有的文件进行tree shaking, 但是可能会删除样式文件, 因为样式文件是直接引入进来的, 所以第一种方案就是把package.json中的配置, 转换为sideEffects: '-.css',这样样式文件就不会被删除了, 第二种方案就是不需要改变sideEffects, 然后在loader中写入sideEffects: true即可</li></ul></li> <li><p>polyfill实现JS兼容性:</p> <ul><li>把ES6的语法会自动的转换成ES5, 可以用来处理js的兼容性问题, 因为浏览器的版本以及不同浏览器之间, 解析的js方式不同, 所以就需要利用babel来配置js的兼容性问题, 但是只能将一些普通的ES6语法转换成ES5语法,一旦一些复杂的语法, 在IE浏览器中的, 如Promise,Async等就不会转换, 就会报错, 所以就可以在入口文件js引入@babel/polyfill, 然后会将所有的ES6语法解析成ES5的语法, 然后可以兼容各种浏览器, 但是因为他是把所有的ES6代码都解析成了ES5, 有些我们没有用的也解析了, 所以代码的体积会变的很大, 就可以利用core-js来解决这个问题, 然后在入口的js文件中也不需要引入@babel/polyfill, 只需要在loader中配置即可, 然后就是当我们的代码写的哪些ES6, 就只会解析我们所写的, 不会全部解析ES6语法。</li></ul></li> <li><p>HMR热模块替换:</p> <ul><li>开启热模块替换功能, 简称HMR, 因为在默认的情况下, 改动一个文件, 会引起整个web程序的刷新, 会全部重新打包, 性能不好, 然后可以利用HMR来实现,改动一个文件, 只更新这一个文件, 其他的不变(性能好), 首先就想要引入webpack然后在添加插件, 并且需要在server中写hot:true, 这样就能实现HMR功能, 但是因为HMR功能默认是在样式文件下生效</li> <li>我们需要在js中也生效的话
<ol><li>就需要在入口的js文件中判断, 有没有开启HMR功能, 如果有开启, 就利用module.hot.accept为需要开启HMR功能的js文件进行开启。</li> <li>在Vue中, 直接使用vue-loader</li> <li>在React中, 使用react-hot-loader</li> <li>这样就能实现, 样式和JS都可以用到HMR功能了, 这样就可以优化性能, 提高程序的运行速度, 提高效率.</li></ol></li></ul></li> <li><p>webpack-spritesmith:</p> <ul><li>用插件制作雪碧图, 就是在开发代码的时候, 会有很多的小图标之类的, 一般这些小图标都是png格式的透明背景图片, 一般用于按钮以及其他元素中, 一般小图标都会有很多个, 虽然体积不大, 但是每用到一次都会发送一次请求, 如果图片多的话, 会占用服务器的内存, 以及占用请求的通道, 因为浏览器的http请求个数是有限的, 会浪费掉请求资源, 我们就可以把多个小图标整合到一张图片中, 然后再利用c3的background-postion来实现, 最后在页面中进行渲染操作, 这样就只发送了一次请求, 即使在别的地方也用到改图片, 也不会再发送请求了, 因为浏览器已经把图片缓存下来了. 因为上述的功能做起来比较麻烦, 需要和UI沟通, 然后需要测量图片的大小以及位置, 然后还要写特定的css, 所有在webpack中的这个webpack-spritesmith插件自动把每一个小图标生成一张大图, 多个http请求变成一个, 然后会自动的测量大图中每个小图标的位置, 帮我们生成对应的css文件.</li></ul></li> <li><p>code split代码分割:</p></li> <li><p>作用:</p> <ul><li>抽取公共的代码, 拆分多个文件, 减少单个文件体积(避免单次请求时间过长)</li> <li>将输出一个JS文件 改成 输出多个JS文件, Object 多入口, 从多个文件开始打包, 然后有多少个就输出多少个文件, 因为全部输出到一个JS文件, 会显得代码臃肿, 而且一般现在开发的都是spa页面, 所以当用户还没有使用到对应的模块的时候, 我们就不需要加载该文件, 如果是全部输出到一个JS文件, 这样就会全部加载, 导致运行速度过慢, 然后利用多入口文件然后输出的时候, 就会输出多少个文件，就可以解决, 但是如果输出的文件还是存在公共的代码, 需要将这个公共代码抽取成单独的文件, 利用optimization,可以将入口JS文件中的node_modules中大于30kb的文件打包成单独的模块.</li> <li>但是需要文件至少在两个入口分别引入,因为开发的时候一般都是单入口, 就没有办法引入两次, 所以就只能打包node_modues代码到单独的文件, 而其他的文件还是会汇总到一个文件中去, 所以体积还是很大, 所以我们就需要动态引入文件, 比如路由组件就需要.在React中就可以使用Suspence+lazy来实现路由组件的动态引入, 然后在Vue中的话, 就直接import引入, 然后包裹在VueRouter中即可</li></ul></li> <li><p>preload/prefetch</p> <ul><li>preload和prefetch都是预加载, 当是preload是预加载当前页面需要使用到的资源, 是当前页面必须使用的, 而prefetch是预加载下一个页面需要的资源, 当前不需要的。他们都会等到其他资源加载完毕之后, 才会去加载. 但是目前还存在兼容性问题.</li></ul></li> <li><p>cache强制缓存</p> <ul><li><p>因为当用户访问过了该页面, 在一定的时间内再次访问就会直接读取缓存的数据, 不会再发送请求, 这样就能有效的减少冗余的数据传输, 减少服务器的压力, 提高网站的性能, 同时也加快了用户访问网页是速度。</p></li> <li><p>但是在webpack中文件被强制缓存起来了之后, 在强制缓存的期间内, 内容无法改变, 就是当我们给当前的文件强制缓存, 就算我们改了代码, 重启了服务器, 页面还是不会有效果, 因为强制缓存没过期, 所以我后面就使用了hash值, 在文件名的后面加上了hash值, 这样, 我修改代码, 重新生成文件的时候, 就不会使用上次的强制缓存了,但是后来发现这样也有问题, 因为如果我只是改了样式的代码, 其他的代码都没有改变, 本应该是样式文件重新请求, 而没有改动的文件, 继续读取缓存, 但是现在会全部刷新, 然后发现, 我所有的文件用的都是一个相同的hash值, 这样一旦有一个文件发送变化, 就全部变化, 所以我就用了chunkhash来代替hash值, chunkhash就是打包生成的每个块都有自己唯一的chunkhash值, 但是观察打包生成的文件名, 发现样式文件和入口文件的chunkhash值一致, 因为css-loader会将样式打包到JS中, 此时JS和CSS就成了一个chunk值了。因为样式和入口文件的chunkhash值一样, 还是没有达到单文件修改只重新发送一个请求, 后来发现可以用contenthash能解决这个问题, 因为contenthash只要文件的内容不一样, hash值就一定会不一样, 虽然名字不一样解决了, 但是后来我动态导入语法对其中一个js文件进行代码的分割, 修改其中一个js文件的时候, 突然发现, 入口的js文件缓存既然失效了, 后来仔细观察打包后入口的的文件时发现, 入口文件中记录了我动态引入js文件的打包chunkId(contenthash生成的),然后我改变动态引入的js文件的时候, 就会自动重新为目前的文件生成一个contenthash值, 只要这个值一变, 因为我入口的js文件中引入了这个js文件的chunkId, 就说明我入口的js文件也改变了, 所以就导致了, 我这个js文件改变, 入口文件也改变的问题。</p></li> <li><p>之后查阅文档发现, 可以将所有JS文件记录Id内容, 提取成单独的文件runtime.xx.js，然后就在optimization中配置了runtimeChunk, 这个配置可以当其中一个js文件发生变化即contenthash值变化, 之会导致runtime.js文件和本身js文件发送变化,而入口的文件则不会变化. 这样就解决了缓存的问题</p></li> <li><p>PWA渐进式网络应用程序</p> <ul><li>即使用户网络断了, 依赖可以使用一些离线的动能, 是利用service Worker实现的, 这个技术就chrome推出的一个web api, 用于给web应用提供高级的可持续的后台处理能力.serveice worker就相当介于服务器和客户端之间的拦截器, 能够拦截进出的http请求, 从而当用户离线的时候, 直接从service worker里面读取, service worker是运行在浏览器后台的, 不受刷新页面的影响, 不能操作DOM但是可以通过事件机制来处理一些问题, 在webpack中需要安装一个插件workbox然后声明使用, 最后在入口的js文件中注册serveice worker, 当项目打包完毕之后, 会产生两个文件, 一个是serveice worker文件,还有一个workbox, 当用户加载完页面, 突然离线断网之后, serveice worker会在浏览器的工作进程中读取缓存存储的数据, workbox里面的内容, 从而即使用户离线, 也可以使用一些以及加载了的功能, 用户体验好</li></ul></li></ul></li></ul> <h3 id="什么是bundle-什么是chunk-什么是module"><a href="#什么是bundle-什么是chunk-什么是module" class="header-anchor">#</a> 什么是bundle,什么是chunk，什么是module</h3> <ul><li>bundle是由webpack打包出来的文件, chunk是指webpack在进行模块的依赖分析的时候, 代码分割出来的代码块, module是开发中的单个模块.</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note_web/chapter4/vue扩展.html" class="prev">
        Vue 扩展
      </a></span> <span class="next"><a href="/note_web/chapter5/webpack总结.html">
        总结 Webpack
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/note_web/assets/js/app.0a8a88e2.js" defer></script><script src="/note_web/assets/js/2.a8152735.js" defer></script><script src="/note_web/assets/js/25.c8dbb4c7.js" defer></script>
  </body>
</html>
